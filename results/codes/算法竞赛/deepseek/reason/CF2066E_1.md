Okay, let's try to understand this problem. So, the task is to determine whether it's possible to identify the poisonous barrel using certain operations and comparisons. The key is to do this without touching the poisonous barrel when pouring, which means we can only pour from non-poisonous barrels into others. 

Hmm. Let me think about the conditions required for identification. The main idea here is to find a way to make sure that after some pour operations, all non-poisonous barrels have the same weight, and the poisonous one is the only one that's different. Because then, comparing the barrels will reveal which one is heavier, which must be the poisonous one (since adding the poison's weight makes it heavier). 

Wait, but the poison adds 0.179 kg. So if all non-poisonous barrels are equal, then the one that's heavier by 0.179 is the poisonous one. But how can we arrange that?

So the approach would be to make all non-poisonous barrels have exactly the same weight. Then, the poisonous barrel will be the only one that's different. But how do we achieve that without knowing which one is poisonous?

Ah, right. Because we don't know which barrel is poisonous, any pouring operation must avoid moving from the poisonous barrel. So, for any pouring we do, we can only move water from barrels that are definitely not the poisonous one. But since we don't know which one it is, the strategy must work regardless of which barrel is the poisonous one.

Wait, that's tricky. So the problem is similar to a scenario where any one of the barrels could be the poisonous one, and we need a strategy that works no matter which one it is. 

So, perhaps the way to do this is to have all barrels except one have the same weight. Then, the one that's different must be the poisonous one. But how?

Wait, maybe the solution is to have the sum of all a_i minus the possible poisonous barrel's a_i, such that the remaining can be partitioned in a way that all non-poisonous barrels have the same weight, and the poisonous one is unique. 

Alternatively, maybe the necessary and sufficient condition is that there exists a subset of barrels S such that the sum of a_i for S is equal to the sum of a_j for the other barrels. Wait, not sure.

Wait, let's think of the initial example. The initial barrels are 2, 2, 4, 11. The output is yes. How was that possible?

The explanation said that first compare the first two barrels. If they are unequal, the heavier is the poisonous. If equal, pour from first into second. Then compare second and third. If unequal, the heavier is poisonous. If equal, then the fourth is poisonous.

So, the key here is that after some operations, the non-poisonous barrels are arranged such that their a_i are all the same. Then, the remaining one (the one that's different) must be the poisonous.

But how to model this?

Wait, maybe the problem reduces to checking if the sum of all a_i minus some a_k (the poisonous barrel) is divisible by (n-1). Because then, each of the other n-1 barrels can have (sum - a_k)/(n-1) amount, which is possible through pouring. But wait, since we can pour from non-poisonous barrels, perhaps we need to arrange that for any possible k (the poisonous barrel), the sum of the others can be divided into equal parts. 

Wait, that's an interesting thought. Let's see. Suppose we have n barrels. For each possible k (1<=k<=n), the sum of the remaining n-1 barrels (sum_total - a_k) must be divisible by (n-1 - 1) = n-2? Because if k is the poisonous barrel, then the other n-1 barrels must be arranged into (n-1) barrels (since we can pour between them). Wait, no, the other n-1 barrels can be poured into each other as long as we don't pour from the poisonous one. Wait, but if k is the poisonous barrel, then any pouring from any other barrel (non-poisonous) is allowed. So the sum of the non-poisonous barrels is sum_total - a_k (since the poison's weight is 0.179, but the a_i includes the poison's weight? Wait, no. Wait, the initial a_i are the water in the barrels, and the poison adds 0.179 kg to exactly one barrel. So the total weight of the barrels is sum(a_i) + 0.179. So the sum of the a_i (water) plus 0.179 kg (poison) is the total weight.

But when comparing the barrels, the poison's weight is included. So for the poisonous barrel i, its weight is a_i +0.179. The others have a_i.

So the key is to arrange the a_i such that for some strategy, after pouring, all non-poisonous barrels have the same weight. Then, the poisonous one's weight (a_i +0.179) will be different, and we can compare to find it.

So the approach would be: for each barrel k, we can pour water among the other barrels (non-poisonous) to make their a_j equal. Because if we can do that for any possible k, then the answer is yes. But how can we do that for all possible k?

Wait, but we don't know which k is the poisonous one. So the strategy must work regardless of which k is chosen. So for each possible k, the sum of the other barrels (sum_total_water - a_k) must be divisible by (n-1) (since we have n-1 non-poisonous barrels, which can be poured into each other to make their total sum equal). Wait, because each of the non-poisonous barrels can be adjusted to have (sum_others) / (n-1) amount. Because you can pour between them. So for each possible k, sum_others = sum(a_i) - a_k must be divisible by (n-1). Because then, each non-poisonous barrel can have exactly sum_others/(n-1) water. Then, the poisonous barrel's total weight would be a_k +0.179, which is different from the others. Then, when we compare all barrels, the one with the highest weight is the poisonous one.

Wait, but how can this be possible for all k? Because sum_others is sum(a_i) -a_k. For each k, sum(a_i) -a_k must be divisible by (n-1). That would require that a_k ≡ sum(a_i) mod (n-1) for all k. Which implies that all a_k are congruent modulo (n-1). But since sum(a_i) is sum of all a_k, sum(a_i) = (n-1)*x + r, then sum_others = sum(a_i) -a_k = (n-1)*x + r -a_k. For this to be divisible by (n-1) for all k, we need that a_k ≡ r mod (n-1) for all k. Because sum_others = (sum(a_i) - a_k) = (n-1)x + r -a_k. For this to be divisible by (n-1), (r -a_k) must be divisible by (n-1), which implies that a_k ≡ r mod (n-1). But since r = sum(a_i) mod (n-1), this would require that all a_k have the same remainder modulo (n-1). 

Wait, but this seems very restrictive. For example, in the demo input:

The initial a_i are 2, 2,4,11. n=4. sum(a_i) = 2+2+4+11=19. n-1 is 3. 19 mod 3 is 1. So sum_others for each k is 19 - a_k. For each k, 19 -a_k must be divisible by 3. Let's check:

For a_1=2: 19-2=17, 17 mod3= 2. Not divisible by 3. So according to this condition, it's not possible. But the demo output says yes. So this approach must be wrong.

Hmm. So maybe the initial approach is incorrect. What's the problem here?

Alternatively, perhaps the condition is that the sum of all a_i, excluding the maximum, should allow the remaining to be divided into (n-1) parts. Wait, maybe the maximum element must be the sum of all others. But that's probably not the case.

Wait, let's look at the demo. The sum of all a_i is 19. For any k, we need sum_others = 19 -a_k. For this to be divisible by (n-1 -1) = 3-1=2? Because the non-poisonous barrels are n-1, but perhaps the sum is divided into (n-1) parts. Wait, perhaps n-1 is the number of non-poisonous barrels. So for each k, the sum_others is (sum_total_water - a_k), and we need to split that into (n-1) barrels, each of equal amount. So sum_others must be divisible by (n-1). 

In the demo, n=4. So for each k, sum_others is 19 - a_k. This sum must be divisible by 3. Let's see:

For a_1=2: sum_others=17. 17/3 is not integer. But the demo's answer is yes. So this condition is not necessary. So my initial approach is wrong.

So there must be a different way to model this problem.

Alternative approach: The key is to have a way to compare barrels such that, after pouring, the poisonous barrel can be uniquely determined. For example, in the demo, the strategy involved comparing pairs and pouring. Let's think of another way.

Suppose we can pour water from some barrels into others in a way that, regardless of which is the poisonous one, the remaining barrels can be made to have the same weight, except possibly the poisonous one. Then, by comparing all barrels, the one that's different (heavier) is the poisonous one.

But how to ensure that. Let's think recursively. For example, if there's one barrel, then it's obviously the poisonous one. For two barrels, we can compare them. If they are equal, then neither is poisonous (but since there must be exactly one, this can't happen). Wait, no. Because in the two-barrel case, one of them must be poisonous. So if their weights are equal, that's impossible. So in that case, it's possible to determine which is the poisonous one. Wait, but according to the problem statement, the poison is present in exactly one barrel, so the scales can't show that they are equal. Wait, no. The scales compare the total weights. So for two barrels, if one is poisonous (adds 0.179 kg), then their weights are a1 and a2 +0.179 (if the second is poisonous). So if a1 = a2 +0.179, then the scales would show that they are equal. But in that case, how do you determine which is the poisonous one? Because if they are equal, but exactly one has the poison, which one is it? Hmm, perhaps the problem's note indicates that when comparing, if the barrels are equal, then the poisonous barrel is not among them. So in the demo explanation, after pouring, the second and third barrels are equal. So if they are equal, then neither is the poisonous one, so the fourth must be.

But how does that work in general? Let's think: if you have some barrels that are equal in weight, then none of them can be the poisonous one. Because the poisonous one would have a higher weight. So, if you can find a group of barrels that are all equal, then the poisonous one is not in that group. 

So the strategy is to create as many equal groups as possible, and through comparisons, narrow down the possible candidates for the poisonous barrel. 

Alternatively, perhaps the problem can be modeled as follows: the answer is "Yes" if and only if there exists a way to split the barrels into groups such that the sum of each group is the same (allowing the poison to be in any group except one). Wait, maybe not. 

Alternatively, think of the problem in terms of the maximum barrel. If all other barrels can be combined into one with sum equal to the maximum, then pouring all into the maximum would make all other barrels zero, and the maximum is the sum of all others. Then, the poisonous barrel would be either the maximum (if it's the only one left) or in the others. But I'm not sure.

Another idea: Let's think of the barrels in terms of their ability to be equalized. For the problem to be solvable, there must be a way to arrange the barrels such that after certain pours, there is exactly one barrel that is heavier than all the others (by 0.179 kg). But how?

Alternatively, the problem can be solved if there's a way to pour water such that all barrels except possibly one are equal. Then, the heavier one is the poisonous barrel.

But how to do that when you don't know which one is poisonous. Because pouring from a non-poisonous barrel is safe. So for example, if you pour all other barrels into one (say, the largest), then the sum of those poured would be added to that barrel. But if that barrel is the poisonous one, then pouring into it is allowed. 

Wait, but if you pour all non-poisonous barrels into one barrel (say, the largest), then all non-poisonous barrels would be zero except the target. Then, the target's weight would be sum of the non-poisonous barrels, and the poisonous one's weight is a_i +0.179. Then, the target's weight (if it's not the poisonous one) would be sum_others. If the target is the poisonous one, then its weight is sum_others (water) +0.179. 

But how to compare these? If after pouring all into one barrel, then the barrels would be: sum_others (if the target is not poisonous), or sum_others +0.179 (if the target is poisonous). The other barrels are zero. So comparing the target to the others would show it's heavier. But how to know if it's the poisonous one or not. This approach might not work.

Alternatively, perhaps the problem is to have a subset of barrels such that their sum is greater than the sum of all others. Then, we can compare the subsets to determine where the poison is. But I'm not sure.

Let's think back to the example. The initial barrels are 2, 2, 4, 11. Sum is 19. The strategy involved pouring between some barrels to make others equal. For instance, pouring from barrel 1 to 2, making them 0 and 4. Then, compare barrel 2 and 3 (4 vs 4). If they are equal, then the poison is in barrel 4. 

So the key here was to arrange pairs of barrels to have equal weight, thereby eliminating them as candidates. Then, the remaining one is the candidate. 

So perhaps the general approach is to have the ability to partition the barrels into groups where each group's sum is the same. Then, through comparisons between groups, we can eliminate groups and narrow down the possible candidates.

But how to model this in code? 

Alternatively, perhaps the answer is "Yes" if and only if there exists a barrel whose a_i is greater than the sum of all other a_i. Because then, if that barrel is not the poisonous one, you can pour all others into it. Then, if it's the sum of others, then comparing it to others (now empty) would show it's heavier. But if that barrel is the poisonous one, its weight would be (sum of others) +0.179. But how does this help? 

Wait, in that case, if there's a barrel with a_i > sum of others, then if it's the poisonous one, its weight is a_i +0.179. The other barrels, after pouring, would have zero. So the only non-zero barrel is the sum of others. Then, comparing the sum of others (a_i) versus a_i +0.179 would show which is heavier. But how can you tell if the sum is in that barrel or if it's the poisonous one?

Alternatively, if you have a barrel with a_i > sum of others, then the only possible way for the sum of others plus the poison to be heavier than that barrel is if the poison is in the sum of others. Wait, perhaps not. 

Alternatively, this approach might not work. Let's think differently.

Another approach is to model this as a problem where the answer is "Yes" if and only if the sum of all a_i is greater than the maximum a_i. But in the demo example, sum is 19, max is 11. 19-11=8, which is less than 11. So sum > max is not true. But the answer is yes. So that condition is not sufficient.

Hmm. So perhaps the key is that the sum of all a_i (excluding the maximum) is greater than or equal to the maximum. Wait, but in the demo, sum excluding 11 is 8, which is less than 11. So that condition is not met. 

This suggests that the approach is different.

Let me try to think of the necessary and sufficient conditions. 

Suppose that the answer is "Yes" if and only if the sum of all a_i is greater than the maximum a_i. Then, the demo example's sum is 19, which is greater than 11. So that condition is met, and the answer is yes. But wait, sum is 19, max is 11. 19 is 8 more than 11. So sum > max is true. So maybe this is the condition.

But let's test another scenario. Suppose there are 3 barrels: 5,5,5. Sum is 15. Max is 5. Sum is 10 more than max. So sum>max. According to the condition, answer is yes. But how would you determine the poisonous barrel? All three are equal. So after any pour, the non-poisonous barrels can be made equal, but the poisonous one will have 5.179. So if you pour all into one barrel, but which one? 

Alternatively, if sum is greater than the maximum, then it's possible to pour from other barrels to make the maximum one's sum equal to the others. But I'm not sure.

Wait, let's take the demo example. Sum is 19. Max is 11. 19-11=8. So the other barrels sum to 8. But how does this help? 

In the demo, the strategy involved comparing pairs. Perhaps the key is that the sum of all a_i is greater than the maximum, allowing us to balance the other barrels.

Alternatively, perhaps the answer is "Yes" if and only if the sum of all a_i is not less than the maximum a_i multiplied by (n-1). Wait, but how?

Alternatively, perhaps the condition is that the sum of all a_i is greater than the maximum a_i. Because then, you can pour from other barrels into the maximum to make it the sum of the others. Wait, but in the demo example, sum is 19, and the max is 11. 19-11=8. So after pouring all other barrels into the max, the max would have 11+8=19. But what if the max is the poisonous one? Then its weight would be 19 +0.179. Otherwise, the max is 19, and the other barrels are zero. Then, the poisonous barrel (which is one of the others) would have 0 +0.179. So comparing the max (19) to others (0.179), you can see which is heavier. So in this case, the max would be 19, and others are 0. So if any of the others is poisonous, their weight is 0.179. So the max is the heaviest. So if the max is not poisonous, then the poisonous one would be among the others. But how do you determine which one? Because you can only compare the max to the others. But if all others are zero, then the poisonous one would be the one with 0.179. So comparing each of them to the max (19) would show that they are lighter. But since they are all zero, but exactly one has 0.179, the scales would show that one is heavier. So you can compare all the zero barrels pairwise to find the one that's heavier. But you can't touch the poisonous one. 

Wait, but if the poisonous barrel is one of the zero barrels, then you can pour from the non-poisonous ones (which are zero) into others. But since they are zero, there's nothing to pour. So perhaps this approach doesn't work.

Alternatively, this suggests that the condition sum > max is not sufficient. 

So maybe the correct condition is that the sum of all barrels except the two largest must be at least as large as the difference between the two largest. Or perhaps some other way to model it.

Alternatively, think of it as a problem where after pouring, the non-poisonous barrels can be arranged into two groups with equal sums. For example, if you can split the non-poisonous barrels into two groups with equal sums, then comparing the sums would allow you to eliminate one group. 

But I'm stuck. Let's look for a pattern in the demo.

In the demo, after the initial setup, the answer is yes. The sum is 19, max is 11. The other three barrels sum to 8. The strategy involved comparing pairs and pouring. So perhaps the key is that the sum of the other barrels is sufficient to allow for comparisons that eliminate candidates.

Another observation: The answer is "Yes" if and only if there exists a way to split the barrels into two subsets such that one subset has sum greater than or equal to the other subset. Then, by comparing the sums, you can determine which subset contains the poisonous barrel. But I'm not sure.

Alternatively, think of it as a problem where the maximum element is at least as large as the sum of all other elements. If that's the case, then it's impossible to split the remaining barrels into equal parts. But in the demo, the sum of others is 8, which is less than 11. So the answer was yes. So that condition is not necessary.

Alternatively, perhaps the answer is yes if and only if there exists a way to form a chain of comparisons that allow us to eliminate barrels.

But how to model this in code for large n and q?

Alternative approach inspired by the demo explanation: The problem can be solved if there's a way to compare pairs of barrels, and based on the result, eliminate some barrels as candidates. For example, comparing two barrels. If their weights are unequal, the heavier one must be the poisonous one. If they are equal, neither is the poisonous one. So, the strategy is to find pairs of barrels that can be compared, and based on the comparison, narrow down the candidates.

But how to structure this for any number of barrels.

Wait, the problem requires that after some pour operations, you can determine the poisonous barrel. So the pour operations must be done in a way that, regardless of which barrel is poisonous, the comparisons will identify it.

So for example, if all barrels except one are equal, then the poisonous one is the different one. But to achieve that, perhaps the sum of all a_i (water) must allow that when you exclude any one a_i, the sum of the remaining a_i is divisible by (n-1). Because then, for any possible poisonous barrel k, the remaining a_i can be split equally into (n-1) barrels, each with sum_others/(n-1) water. Then, the poisonous barrel's weight is a_k +0.179, which is higher than any of the others (sum_others/(n-1)). So comparing all barrels would reveal that the poisonous one is the one with higher weight.

So the condition for the answer to be yes is that for every barrel k, sum_others = sum(a_i) -a_k must be divisible by (n-1). Because then, you can split the remaining barrels into (n-1) equal parts, each of sum_others/(n-1). 

But in the demo, sum_others for k=4 (a_k=11) is 19-11=8. 8 divided by (n-1)=3 is 8/3, which is not an integer. But the answer was yes. So this condition is not required.

So this suggests that the initial approach is incorrect. 

Alternative idea: Maybe it's sufficient that the sum of all a_i is greater than the maximum a_i. Then, regardless of which barrel is the poisonous one, we can pour the other barrels into a single one to create a sum that is higher than the maximum, allowing comparisons to find the heavier one. 

In the demo, sum is 19, which is greater than 11. So yes. If sum is less than or equal to the maximum, then it's impossible. For example, if there are barrels 3 and 4, sum is 7. Max is4. Sum is 3>4? No, so sum is 3+4=7. But 7 is greater than 4, sum is 7>4. Wait, sum is greater than max. So according to this condition, answer is yes. But how?

Suppose we have barrels 3 and 4. Sum is7. Max is4. So sum>max. So answer is yes. How?

If the poisonous barrel is the 4 one: its weight is 4+0.179. The other is 3. So comparing them would show the 4+0.179 is heavier. So it's the poisonous one. If the poisonous is the 3 one: its weight is 3+0.179. The other is4. So comparing shows 4 is heavier. So the 3 is poisonous. So how do we know which is which?

Wait, in this case, the scales would compare 3+0.179 and4. So the scales would show that 4 is heavier. So according to that, the poisonous barrel would be the 3, since the 4 is non-poisonous. So the strategy is to compare the two barrels. If they are unequal, the heavier one is non-poisonous (since the poisonous one has +0.179). Wait, no. If the heavier one is non-poisonous, then its weight is a_i. The poisonous one's weight is a_j +0.179. So if the non-poisonous is heavier, then a_i > a_j +0.179. But this may not hold. 

For example, if the two barrels are 3 and4. Sum is7>4. If the poisonous is the 3, then their weights are 3.179 and4. The scales show that 4 is heavier. So the poisonous barrel is the lighter one. But how do you know that?

So this approach wouldn't work. Because the scales show that 4 is heavier than 3.179, so the poisonous barrel is the 3. But how can you determine that based on the comparison?

So this suggests that the sum>max condition is not sufficient. 

Alternative approach inspired by the problem's note: The key is to have a way to split the barrels into groups where each group's sum is the same, allowing us to eliminate groups by comparison. For example, in the demo, after pouring, the first and second barrels were equal. If they are not equal, then the heavier one is the poisonous. If they are equal, they are not poisonous. Then, pour from the first into the second to make it 4, compare with the third. If equal, then the fourth is the poisonous. 

So the idea is to build a chain of comparisons that eliminates possible candidates. 

To model this, perhaps the answer is yes if and only if the multiset of a_i can be partitioned into pairs or groups where the sum of each group is the same. But again, this is unclear.

Alternatively, perhaps the answer is yes if and only if there exists a barrel that is the sum of all others. For example, in the demo, the fourth barrel is 11, which is equal to the sum of the others (2+2+4=8), no. Wait, no. 11 is not the sum of others. So that's not the case.

Alternatively, maybe the answer is yes when the sum of all a_i is greater than or equal to the maximum a_i multiplied by 2. Because then, you can split the sum into two parts, each >= max. But again, not sure.

Let's try to think of other examples. Suppose we have three barrels: 3,3,3. Sum is9. Max is3. Sum>max. So according to sum>max condition, answer is yes. How?

If we compare any two. Suppose they are all 3. Then, each has a_i=3. If one is poisonous, its weight is 3.179. So comparing any two barrels: if one is heavier, that's the poisonous. If they are equal, then they are non-poisonous, and the third is the poisonous one. So yes, possible. So in this case, sum>max (9>3) and answer is yes.

Another example: barrels 1,1. Sum is2>1. How to compare? The two barrels are 1 and 1. If one is poisonous, their weights are 1.179 and1. So comparing shows that one is heavier, which is the poisonous. So answer is yes.

Another example: barrels 5,5. Sum 10>5. If one is poisonous, their weights are 5.179 and5. So comparing shows which is heavier. Answer is yes.

Another example: barrels 1,4. Sum is5>4. Yes. Compare the two. If one is heavier, it's the poisonous. So yes.

Now, consider a case where sum <= max. For example, barrels 5,3. Sum is8>5. Sum>max. So answer is yes. But what if sum is less than max? For example, barrels 5 and 3. Sum is8>5. So sum>max. Hmm, no. Wait, 5+3=8>5. So sum>max. So sum can be greater than max even if max is larger than individual elements. So how to have sum <=max? For example, barrels 10, 5. Sum is15>10. Sum>max. So sum is always greater than max when there are two or more barrels. Only when there's one barrel sum equals max.

So the sum>max condition is always true for n>=2. But this can't be right, since in the demo example, sum is 19, which is greater than max 11, but the answer is yes. But when n=2, sum is always greater than max (since sum = max + other), which is greater than max. So sum>max is always true for n>=2. So this condition is not useful.

Hmm. So this approach is not working. 

Alternative approach inspired by the problem's note and the demo explanation: The answer is "Yes" if and only if there exists a way to pair barrels such that for each pair, their a_i's are equal. Then, after comparing the pairs, we can eliminate pairs where the two are equal (since the poisonous is not in them). The remaining unpaired barrels would be the candidate.

But how to model this for any number of barrels. 

Alternatively, the answer is "Yes" if the multiset of a_i can be partitioned into groups where each group has sum equal to each other. Then, through comparisons, we can eliminate groups and find the poisonous barrel. 

But again, this is not clear.

Another idea: The answer is "Yes" if there exists a subset of barrels such that the sum of the subset is equal to the sum of the complement subset. This way, comparing the two subsets would determine which contains the poisonous barrel. If the sums are equal, then the poisonous is in neither subset (but this can't happen). So perhaps this approach is not helpful.

Alternatively, perhaps the answer is "Yes" if the sum of all a_i is greater than the maximum a_i. But as discussed earlier, this is always true for n>=2, which is not the case. For example, in the case of three barrels: 10, 1, 1. Sum is12>10. So answer is yes. How?

Compare the two 1's. If they are equal, neither is poisonous. Then, the poisonous must be the 10. So in that case, you can determine it. If the two 1's are unequal (which they can't be, but if one is poisonous, then one is 1.179 and the other is 1. So compare them: the heavier one is the poisonous. If they are equal, the 10 is not poisonous. So yes, possible.

Another example: barrels 5, 5, 5. Sum is15>5. Yes. Compare any two. If equal, compare the third. So answer is yes.

So in all these examples, the answer is yes. So when is the answer no?

Looking at the demo output: after the first query "- 2", the barrels are [2,4,11]. n=3. The answer is "No". Sum is17, which is greater than 11. So sum>max but answer is no. So the sum>max condition is not sufficient.

Ah, this is a key example. So sum>max is not sufficient. So what is the condition here?

After the first query, the barrels are 2,4,11. So n=3. The sum is 17. So sum>max (11). But answer is "No". So why is that? Why can't we determine the poisonous barrel?

So, perhaps in this case, it's impossible to pour the barrels into a configuration where you can determine the poisonous one.

Let's see. How could we approach this scenario.

We need to find a way to pour water such that after pouring, the non-poisonous barrels have equal weight, and the poisonous one is different.

For any possible poisonous barrel k (1,2,3), the sum of the other two is sum_others = sum - a_k. We need to split sum_others into (n-1) barrels, which in this case, n-1=2. So sum_others must be divisible by 2.

For each k:

- If k=1 (a_k=2), sum_others = 4+11=15. 15/2=7.5. So the two non-poisonous barrels can be 7.5 each. Then, the poisonous one's weight is 2+0.179=2.179. But the non-poisonous are 7.5 and 7.5. So the poisonous one is lighter than them. So comparing all three, the two non-poisonous are heavier and equal. So the poisonous is the lightest. So we can determine.

- If k=2 (a_k=4), sum_others=2+11=13. 13/2=6.5. So non-poisonous barrels are 6.5 each. Poisonous is 4+0.179=4.179. Again, the poisonous is lighter than the non-poisonous, so compare and find the lightest.

- If k=3 (a_k=11), sum_others=2+4=6. 6/2=3. So non-poisonous are 3 each. Poisonous is 11+0.179=11.179. Heavier than the others. So compare all three. The one that's heavier is the poisonous.

So in all cases, the non-poisonous barrels can be split into equal parts. So according to this, the answer should be yes. But according to the demo output, after removing the 2, the answer is "No". So why is this contradiction?

Ah, perhaps my reasoning is wrong. Because in this case, when k=3 (a_k=11), sum_others=6, which can be divided into 3 and 3. So the two non-poisonous barrels have 3 each. But the original barrels are 2 and4. How can you split them into 3 and3? Because you can't pour from the poisonous barrel (k=3). So the sum of the other two is6. You need to make them 3 each. So you can pour from the 4 into the 2. So 4-1=3, 2+1=3. But if the poisonous barrel is 3, then it's allowed to pour into it. Wait, no. If the poisonous barrel is 3, then you can't pour from barrels 1 and2. But the pouring from 4 to 2 is allowed only if 4 is not poisonous. But in this case, the poisonous is barrel3. So pouring from 4 (non-poisonous) into 2 (non-poisonous) is allowed. So yes, you can do that.

So after pouring, the two non-poisonous barrels are 3 and3, and the poisonous is 11.179. Comparing the three, the poisonous is the only one that's heavier, so it's identified. So why is the demo output "No" after the first query?

This suggests that there's a mistake in my reasoning. 

Wait, the demo input after the first query is:

Initial barrels: 4 7

After the first query is "- 2", which removes one of the two 2's. So the barrels become 2,4,11. Then, the answer is "No".

So in this case, the sum is 17. But according to the reasoning above, it's possible to split the non-poisonous barrels into equal parts for any k. So why is the answer no?

Ah, wait, the problem is that the sum_others for k=3 is 2+4=6. 6 divided by 2 (n-1=3-1=2) gives 3. So you can split them into 3 and3. But to do that, you need to pour from barrel4 (the a_i=4) into barrel2 (a_i=2). But if barrel4 is non-poisonous (since the poisonous is barrel3), then this is allowed. So the new a_i would be 3 and3. 

But then, when comparing barrels1 and barrel2 (both 3), they are equal. So the poisonous is barrel3, which is 11.179. So compare it to the others: it's heavier. So you can identify it.

But why is the answer no?

This suggests that there's a flaw in my reasoning. Maybe the problem is that when the poisonous barrel is one of the non-split barrels, the process of pouring is not possible. Or perhaps there's a different condition.

Alternatively, perhaps the problem is that the sum_others for k=3 is 6, but the individual barrels are 2 and4. You need to split them into 3 and3, which requires pouring 1 kg from the 4 to the 2. But this is possible. So why can't this be done?

The demo output says that after removing a 2, the answer is "No". So what's wrong with the above approach?

Wait, perhaps the problem is that when you pour from the 4 to the 2, you have to handle the 4. But if the 4 is the poisonous barrel, then pouring from it would cause death. So the pouring steps must be designed in a way that regardless of which barrel is the poisonous one, you don't touch it during pouring.

Ah! This is the key. Because if you pour from barrel4 (the a_i=4), you can only do that if you know it's not the poisonous one. But in reality, you don't know which one is the poisonous one. So any pouring must be done in such a way that you don't pour from the poisonous barrel. But since you don't know which one is poisonous, you need a strategy that works regardless of which barrel is the poisonous one.

This is a critical insight. So, for example, if you have a pouring step that involves pouring from barrel A to barrel B, you must ensure that A is not the poisonous barrel. But since you don't know which is the poisonous one, you can't pour from any barrel that could possibly be the poisonous one. 

Thus, the pouring steps must be such that, regardless of which barrel is the poisonous one, the steps are safe. This means that any pouring must only be done from barrels that are known to be non-poisonous. But since you don't know which ones are non-poisonous, the pouring steps must be such that even if some barrels are poisonous, the steps don't require pouring from them.

So, for example, in the case of barrels 2,4,11 after the first query, when n=3:

Suppose we want to pour from the 4 to the 2 to make them 3 and3. But if the 4 is the poisonous barrel, then pouring from it would kill us. So that pouring step is not allowed. 

So, the pouring steps must be designed such that no matter which barrel is the poisonous one, we don't pour from it. How can this be achieved?

Ah, this is the crux of the problem. So the pouring steps must be such that the set of barrels we pour from is the same for any possible poisonous barrel. Or, the strategy must not depend on the location of the poison.

So, the problem requires that there exists a sequence of pouring operations that are safe regardless of which barrel is poisonous. 

Thus, the only safe way to pour is to pour from barrels that are known to be non-poisonous. But how can we know that a barrel is non-poisonous?

Wait, perhaps through comparisons. For example, if two barrels are compared and found to be equal, they are non-poisonous. So then, you can pour from them safely. 

Thus, the strategy is to find a way to compare barrels, and based on the comparisons, identify non-poisonous barrels that can be safely poured from. 

For example, in the initial demo case, the first two barrels are compared. If they are unequal, the heavier one is the poisonous. If they are equal, then they are non-poisonous, and you can pour from them into others. 

So, the answer is yes if and only if there exists a way to compare barrels such that you can identify non-poisonous barrels, and use them to pour into others, ultimately leading to the identification of the poisonous one.

But how to model this for code.

Alternative approach inspired by the problem's note: 

The answer is "Yes" if and only if there exists a subset of barrels that can be divided into pairs where each pair's sum is the same, or there's a way to form a chain of comparisons to eliminate candidates.

But I'm not sure.

Another idea inspired by the demo explanation: 

The answer is "Yes" if and only if there exists a way to pair all barrels except one into equal pairs. The remaining barrel is the candidate. 

But again, not sure.

Alternatively, perhaps the necessary and sufficient condition is that the multiset of a_i has at least two barrels with the same value. Because then, you can compare them. If they are equal, then neither is poisonous, and you can use them to pour into others. If not equal, the heavier is poisonous. 

But in the demo after the first query, the barrels are 2,4,11. There are no two equal barrels. So comparing any two will result in unequal, and the heavier one could be the poisonous. But if the poisonous is the lightest, then the comparison would show the heavier is non-poisonous. But how to determine that.

In this case, compare 2 and4. If the 4 is heavier, then it's possible that it's the poisonous one (if a_i=4, then 4+0.179=4.179). Or, if the 2 is the poisonous one (2+0.179=2.179), then the 4 is non-poisonous. But comparing 2 and4 would show that 4 is heavier. In this case, how do you determine which is the poisonous one?

For example, if the poisonous is the 4: the weight of 4+0.179 =4.179. The 2 is 2. So the comparison shows 4.179 is heavier than 2. So you can conclude that the 4 is poisonous. 

If the poisonous is the 2: its weight is 2.179. The 4 is 4. So comparison shows 4 is heavier. So you can't determine that the 2 is poisonous, because the 4 is non-poisonous. So the strategy would incorrectly select the 4 as the poisonous barrel. 

So this approach would fail. 

Thus, when there are no pairs of equal barrels, it's impossible to determine the poisonous one through pairwise comparisons. Because the comparisons may not give enough information.

Thus, the key is that there must be at least two barrels with the same a_i. This allows for the initial comparison to determine whether they are poisonous or not. 

In the demo after the first query, there are no two equal barrels. So the answer is no. 

So perhaps the answer is "Yes" if and only if there exists at least two barrels with the same a_i. 

Let's test this hypothesis.

In the initial demo case, there are two 2's. So answer is yes. 

After the first query, one of the 2's is removed. The remaining barrels are 2,4,11. So no two are equal. Answer is no.

Then, the next query is +4. Now, the barrels are 2,4,4,11. Now, there are two 4's. So answer is yes.

But wait, according to the demo output, after the first query, the answer is no. Then, after the second query, which is "+4", the answer becomes yes. Which aligns with this hypothesis.

The next query is "+30", making the barrels 2,4,4,11,30. Now, there are two 4's. Answer is yes. But according to the demo output, the answer after this query is "No". So this contradicts the hypothesis.

So the answer after adding 30 is no. But there are two 4's. So the hypothesis is incorrect.

Hmm. So this suggests that the existence of a pair of equal barrels is not sufficient. 

But why after adding 4, the answer is yes. 

In the query "+4", the new barrels are 2,4,4,11. So n=4. sum is 21. 

Now, two 4's. So according to the hypothesis, answer is yes. But according to the demo output, after this query, the answer is yes. Then the next query is "+30", making the barrels 2,4,4,11,30. sum is 51. 

In this case, there are two 4's. So the answer would be yes according to the hypothesis. But according to the demo output, the answer is "No". So the hypothesis is incorrect. 

Thus, the presence of two equal barrels is not sufficient. 

So, what's the correct condition?

Let's look at the demo's query sequence:

After the first query "- 2", the barrels are 2,4,11. Answer is no. 

Second query "+4": barrels are 2,4,4,11. Answer is yes. 

Third query "+30": barrels are 2,4,4,11,30. Answer is no. 

Fourth query "+40": barrels are 2,4,4,11,30,40. Answer is yes. 

Wait, after adding 30, answer is no. Then adding 40, answer is yes. 

But when we add 40, the barrels are 2,4,4,11,30,40. So there are two 4's. 

So why is the answer after adding 40 yes? 

Ah, perhaps the answer is yes if the multiset contains a pair of barrels with the same value, and the sum of all other barrels is greater than or equal to the maximum value. 

But in the case of adding 30, the sum of other barrels (2+4+4+11+30) =51. Max is 30. So sum is 51>30. But answer is no. 

Hmm. This is getting complicated. 

Alternative approach: The answer is "Yes" if and only if there exists a subset of barrels that can be partitioned into pairs such that for each pair, their sum is the same. 

But again, not sure. 

Alternatively, perhaps the answer is "Yes" if there exists a way to perform a sequence of comparisons and pour operations such that after each step, the number of possible candidates for the poisonous barrel is reduced by at least one. 

But how to model this.

Alternatively, after reading the problem's note again: The strategy in the demo involved comparing pairs of barrels and using the result to determine whether they are poisonous. 

In the initial case:

1. Compare barrels 1 and 2. 

   a. If they are not equal, the heavier is the poisonous.

   b. If equal, pour from 1 to 2 to make it 0 and 4, then compare barrel 2 and 3.

       i. If they are not equal, the heavier is poisonous.

       ii. If equal, the fourth barrel is poisonous.

So the key here is that after comparing two barrels, you can either determine the poisonous barrel or eliminate those two as candidates and proceed.

Thus, the strategy requires that for each step, you have a pair of barrels to compare, and the result of the comparison allows you to either find the poisonous barrel or eliminate them from consideration.

So, the answer is "Yes" if there's a way to form a binary search tree-like structure of comparisons that allows you to narrow down the candidates.

But how to model this for a general case.

The problem seems to require that the multiset of a_i can be partitioned into pairs where the sum of each pair is the same, allowing for comparisons to eliminate pairs. 

Alternatively, the answer is "Yes" if the multiset of a_i has at least two barrels with the same value, and the sum of the remaining barrels is less than or equal to the maximum value. But I'm not sure.

Alternatively, after some research, I recall that this problem is similar to a classic problem where you need to determine a single defective item using balance scales. The solution involves comparisons and partitioning the items into groups. 

In this case, the answer is "Yes" if there exists a subset of barrels that can be used to compare and eliminate possibilities. 

But I'm still stuck.

Another approach inspired by the problem's note: 

The strategy is to form a chain of comparisons. For example, compare pairs of barrels. If they are equal, they are not poisonous. Use them to pour into other barrels to create new pairs. Repeat until only one candidate remains.

For this strategy to work, there must be at least one pair of barrels with the same a_i. 

But after adding 30 in the demo, there are two 4's but the answer is no. So this is not sufficient.

Wait, in the third query of the demo:

After the second query "+4", the barrels are 2,4,4,11. Now, there are two 4's. So the answer is yes. 

The strategy would be:

Compare the two 4's. If they are unequal, the heavier is poisonous. If equal, then they are non-poisonous. Pour from one into the other, then compare with another barrel.

But after pouring from 4 to 4 (which is allowed), but if they are non-poisonous, then pouring is safe. 

But why after adding 30, the answer is no. 

Ah, perhaps the answer is "Yes" if there exists a pair of barrels with the same a_i, and the sum of the remaining barrels is not greater than the maximum a_i. 

Wait, in the case after adding 30:

Barrels are 2,4,4,11,30. Sum of others is 2+4+4+11+30=51. Max is30. 51>30. So sum of others is 51>30.

But then, even if you have two 4's, the sum of others (30) is 30. So if you compare the two 4's. If they are equal, then they are non-poisonous. Pour from one into the other to make 8. Then compare with 2. If equal, pour into 11, etc. But perhaps this is not possible. 

Alternatively, perhaps the answer is "Yes" if and only if there exists a pair of barrels with the same a_i, and the sum of all a_i excluding these two is <= the maximum a_i. 

But in the demo after adding 30, the two 4's are present, but the sum of others is 2+11+30=43>30. So this condition is not met. So answer is no.

But in the initial demo after adding 40, the answer is yes. Barrels are 2,4,4,11,30,40. Sum of others after pairing the 4's is 2+11+30+40=83>40. So sum is greater than max. But answer is yes. So this condition is not sufficient.

This is very challenging. 

Perhaps the correct condition is that there exists a pair of barrels with the same a_i, and the sum of all other barrels is <= the maximum a_i. But how to verify this.

Alternatively, perhaps the answer is yes if and only if there exists a pair of barrels with the same a_i, and after pouring from other barrels into a single one, the maximum a_i is at least the sum of all others. 

But I'm not sure.

Another idea: The problem can be solved by checking if the multiset has at least two elements with the same value. But this isn't always the case. For example, in the demo after adding 40, there are two 4's, but answer is yes. But after adding 30, there are two 4's but answer is no. So this suggests that the condition is more complex.

Alternatively, the answer is "Yes" if and only if there exists a pair of barrels with the same a_i and the sum of the remaining barrels is even. But this is just a guess.

Alternatively, the answer is "Yes" if there exists a pair of barrels with the same a_i, and the sum of the other a_i's is <= the maximum a_i of those others. 

But this is also unclear.

Perhaps the correct approach is to realize that the problem can be solved if there exists a way to have all non-poisonous barrels have the same weight. For this to be possible, for each possible poisonous barrel k, the sum of the other barrels must be divisible by (n-1). 

But earlier this was disproven with the demo example. 

Alternatively, this condition must hold for at least one barrel k. 

In the initial demo, for k=4 (a_i=11), sum_others=8, which is not divisible by 3. But the answer is yes. So this condition is not required.

Thus, I'm stuck. 

Given the time constraints, perhaps the correct approach is to look for patterns in the demo and derive the correct condition.

In the demo output:

After each query, the answer is "Yes" if there exists at least two barrels with the same a_i and the sum of all other barrels is greater than or equal to the maximum a_i. Or perhaps not.

Alternatively, the answer is "Yes" if there exists a pair of barrels with the same a_i and the sum of the rest is greater than or equal to the maximum a_i. 

But I'm not sure. 

Given the time, perhaps the correct condition is that there exists a pair of barrels with the same a_i, and the sum of the remaining barrels is >= the maximum a_i. 

But in the demo after adding 30, the pair of 4's is present, sum of others is 2+11+30=43 >=30. So the answer should be yes. But according to the demo, it's no. So this is incorrect.

Thus, this approach is not working. 

Given that I'm stuck, perhaps I need to look for the correct solution elsewhere. 

Upon further research, I find that this problem is similar to the problem of finding a balance in the weights, and the solution involves ensuring that the sum of all weights except the maximum is at least the maximum. This is known as the 'sim' condition in some problems. 

The 'sim' condition states that if the sum of all elements except the largest is greater than or equal to the largest, then it's possible to balance them. 

In this problem, perhaps the answer is "Yes" if and only if the sum of all barrels except the largest is >= the largest. 

Let's test this:

In the initial demo: sum of others is 2+2+4=8, largest is 11. 8 <11. So condition is not met. But the answer is yes. So this is not the case.

In the first query after removing 2: barrels are 2,4,11. sum of others is 6<11. Condition not met. Answer is no. 

Second query adds 4: barrels are 2,4,4,11. sum of others is 2+4+4=10 >=11? No. 10<11. So condition not met. But the answer is yes. So this is also not the case.

So this condition is not sufficient. 

Another observation: The demo's answer after adding 40 is yes. The barrels are 2,4,4,11,30,40. sum of others is 2+4+4+11+30=51, largest is40. 51 >=40. So condition is met. Answer is yes. 

After adding 30 (barrels are 2,4,4,11,30), sum of others is 2+4+4+11=21 <30. So condition not met. Answer is no. 

After adding 40, sum of others is51 >=40. Answer is yes. 

So this aligns with the sum of others >= max. 

But in the initial demo, sum of others is8 <11. Answer is yes. So this condition is not necessary. 

But according to this, the answer is yes when sum of others >= max. Otherwise, no. 

But initial demo contradicts this. So perhaps the condition is sum of all barrels except the two largest is >= the third largest, but I'm not sure.

Alternatively, the correct condition is sum of all barrels except the largest is >= largest minus the second largest. 

But this also seems arbitrary.

Given the time constraints, perhaps the correct approach is to code based on the sum of all barrels except the maximum >= maximum. 

But according to the demo, this is not the case. 

Alternatively, perhaps the answer is "Yes" if and only if there exists a barrel that can be the largest after pouring, and the sum of all other barrels is >= this largest. 

But I'm not sure. 

After struggling with this, I think the correct approach is to realize that the answer is "Yes" if and only if there exists a pair of barrels with the same value, and the sum of all barrels except those two is greater than or equal to the maximum of the remaining barrels. 

But I'm not sure. 

Given the time, I think the correct approach is to look for the following conditions:

1. The sum of all a_i must be greater than the maximum a_i. This allows the remaining barrels to be poured into the maximum to make it the sum of the others. 

But this is not sufficient.

Alternatively, the answer is "Yes" if and only if the sum of all a_i is greater than the maximum a_i multiplied by 2. 

But again, not sure.

Given the time, perhaps the correct approach is to code based on whether there exists a pair of barrels with the same a_i. 

But this is not correct, but given the demo, this seems to work in some cases. 

But in the demo after adding 30, there are two 4's, but answer is no. 

Thus, this approach is incorrect. 

After much deliberation, I realize that the correct condition is that the sum of all a_i except the maximum must be >= the maximum a_i. This is known as the "sim" condition, which allows for the creation of a balanced set. 

But according to the initial demo, this condition is not met. 

But in the initial demo, the answer is yes. So this can't be the case. 

Thus, I'm stuck and need to proceed to code based on this condition, even though it's not correct. But given the time constraints, I'll proceed. 

The code will check if the sum of all a_i except the maximum is >= the maximum. 

For each query, we need to track the sum and the maximum. 

But according to the demo, this is not correct. 

Alternatively, the correct condition is that sum of all a_i except the maximum is >= maximum a_i minus 0.179. But this is not possible. 

Alternatively, the answer is "Yes" if and only if the sum of all a_i except the maximum is >= maximum a_i minus the minimum possible poison (0.179). But this is unclear. 

Given the time constraints, I'll proceed to code the condition where the sum of all a_i except the maximum is >= the maximum a_i. 

But in the initial demo, sum_others=8 <11, so the answer would be no, which contradicts the demo. So this approach is wrong. 

Thus, I'm out of options and must conclude that the correct approach is to find whether there exists a pair of barrels with the same a_i. 

But in the demo after adding 30, there are two 4's, but answer is no. So this is not the case. 

Thus, I'm stuck and unable to proceed further.