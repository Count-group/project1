Okay, I need to solve this problem where we have to count the number of valid ways to fill in the gaps in a sequence of airplane launches. The constraints are a bit tricky. Let me try to understand the problem again.

So, each person on floor i will stop launching once they see at least c airplanes. But the way they see airplanes is from their floor and all below. Wait, no—the problem says when a person on floor i launches, all floors from 1 to i can see it. Wait, the problem statement says: when a person from the i-th floor launches, all residents on floors from 1 to i can see it. So, for someone on floor i, their count is the number of airplanes launched by floors 1 to i. Wait, no. Wait, when a person on floor i launches, that airplane is visible to floors 1 to i. But each airplane contributes to the count of all floors >= j where j is the floor it was launched from. Because if you launch from floor j, then all floors up to j (including j) can see it. So for any floor k <= j, that airplane counts towards their total. So, for a person on floor i, the total number of airplanes they've seen is the number of airplanes launched from floors >= i. Because any airplane launched from floor j >= i will be visible to floor i. Because when j >= i, the person on i is in 1..j. So, the total for floor i is the sum of all airplanes launched from floors i, i+1, ..., n. Because each such airplane is visible to i.

Wait, no. Let me recheck. Suppose the airplane is launched from floor j. Then floors 1 to j can see it. So, for floor i, the airplane is visible if j >= i. Because i is between 1 and j. So, the count for floor i is the number of airplanes launched from floors >= i.

So each time a person launches a plane from floor j, all floors <= j (including j) can see it. But for a person on floor i, they see all planes launched from floors >= i. Because those planes were launched from floors j >= i, so i is within 1..j.

Therefore, for the person on floor i, their count is the number of airplanes launched from floors >= i. And they will stop launching once this count reaches c. But during the process, when they decide to launch, their current count (including their own previous launches) must be less than c.

The problem requires that after all m airplanes are launched, each floor i's count (sum of airplanes from i to n) must be at least c. Also, during the sequence, when a person launches a plane (say from j), the sum of planes launched from >=j up to that point (including this new plane) must be <= c. Because the person j launches only if their current count (sum from j to n up to that point) is less than c. Wait, no. Wait, when a person from i-th floor launches, they check if their current view (sum from i to n of planes before this launch) is >= c. If it is, they do not launch. Otherwise, they do.

Wait, the problem statement says: when a person on the i-th floor launches, all residents on 1 to i can see it. Then, if from the perspective of the resident on the i-th floor, at least c airplanes have already been launched, they will not launch. So, the resident i checks the number of airplanes that have been launched by themselves and higher floors (i to n) up to that point (before their own launch). If that sum is >= c, they don't launch. Otherwise, they do.

Wait, no. The wording is a bit confusing. Let me parse it again.

"When a person from the i-th floor launches an airplane, all residents on floors from 1 to i can see it as it descends to the ground. If, from the perspective of the resident on the i-th floor, at least c airplanes have already been launched, they will no longer launch airplanes themselves."

So, the resident i's perspective is the number of airplanes that have been launched up to that moment (including their own previous launches) from floors >= i. Because when they launch, their own plane contributes to their count. Wait, but at the moment they decide to launch, they check if the count (sum of airplanes from floors >= i, including any previous ones) is already >= c. If so, they won't launch. So their current count (sum of >=i) must be <c for them to launch.

But in the given sequence, some positions are already filled (non-zero) and others are zero (gaps). We need to fill the gaps with floor numbers such that, for each launch in the sequence:

- The resident a_i (the floor number) must have their current sum (sum of >= a_i) before this launch being less than c. Because they decided to launch.

Moreover, after all m launches, each floor's sum (sum of >=i) must be >=c.

So, the problem is to count the number of valid sequences that meet these constraints.

This seems complex. Let's think about the approach.

First, the key points:

1. For each position in the sequence, if it's filled with j (non-zero), then when that plane is launched, the sum of planes from floors >=j (including this one) up to that point (before adding this plane) must be less than c. Because the resident j would not have launched if their sum was already >=c.

Wait, no. Let's clarify:

At the moment when the resident j launches the airplane, they check their current sum (sum of >=j) BEFORE adding this airplane. Because if their sum was already >=c, they would not launch. So when the airplane is added, their sum (including this airplane) would be sum_prev + 1, which must be <= c. Because sum_prev (before adding) must be <c. So, sum_prev +1 <= c.

Therefore, for each airplane in the sequence, if it is j, then the sum of >=j in the sequence up to that point (before this airplane) must be <c. Because they decide to launch, which implies sum_prev <c. Then, after adding this airplane, the sum becomes sum_prev +1. Which could be <=c.

But after all airplanes are launched, each sum >=i must be >=c.

So, the sum of >=i for each i must be exactly c, because each airplane added for floor j contributes to the sum of >=i for all i <=j. Wait, no. The sum can be more than c, but the problem states that each resident stops launching once their sum reaches c. But the problem says that the total number of airplanes is m. Wait, but the problem says that the total number of airplanes is m, and after all are launched, each sum >=i must be >=c.

But during the process, each resident can launch even after their sum has reached c, as long as their previous sum before launching was less than c. Wait, no. Because once their sum (sum of >=i) reaches c, they stop. So, they can't launch if the sum after their previous launches (and others') is >=c.

Wait, perhaps not. Let's re-examine the problem statement.

"If, from the perspective of the resident on the i-th floor, at least c airplanes have already been launched, they will no longer launch airplanes themselves."

The key phrase is "have already been launched"—so before their own launch. So, if the sum of >=i (including previous launches) is >=c, the resident i will not launch.

Therefore, for each airplane in the sequence that is launched by floor j, the sum of >=j in the previous steps (before this airplane is added) must be <c. Because otherwise, the resident would not launch.

So, for each airplane in the sequence, if it's j, then the sum of >=j in the sequence up to that point (before this airplane) is s_j_prev, and s_j_prev <c. Then, when added, s_j becomes s_j_prev +1. But s_j_prev can be up to c-1.

At the end, for each i, the sum of >=i must be >=c.

So, the constraints are:

For each position k in the sequence (1-based?), the a_k (the floor) must be such that the sum of >=a_k in the sequence up to k-1 (before this a_k is added) is less than c. And after all m airplanes, for each i, sum of >=i in the entire sequence is >=c.

This is a bit tricky. Let's model the process step by step.

At each step, we can track for each i, the number of airplanes launched from floors >=i. Let's call this s_i.

Initially, all s_i are 0.

For each airplane in the sequence:

- Let the current airplane be j. Then, before adding this airplane, s_j must be <c. Because otherwise, the resident j would not launch.

- When adding j, all s_i for i <=j are increased by 1. Wait, no. Because j is a floor >=i for all i <=j. So, adding a plane from j contributes to s_i for i <=j.

So, for each i <=j, s_i +=1.

Wait, but s_i is the sum of >=i. So, any airplane from a floor >=i contributes to s_i. So, adding an airplane to j (floor j) will contribute to s_i for all i <=j.

Therefore, when we add a plane to j, we need to increment s_1, s_2, ..., s_j.

But keeping track of s_1 to s_j for each step is O(n) per step, which might be manageable for small n (n up to 100, m up to 1e4, but t up to 1e4 as well). But this seems computationally heavy.

Wait, but the problem constraints have n up to 100, m up to 1e4, and t up to 1e4, but the sum of m across test cases is 1e4. So, per test case, m is up to 1e4. But even with O(m * n) per test case, it's manageable.

But how do we model the state in the dynamic programming?

Alternative approach: model the state as the current values of s_1 to s_n, but since s_i is the sum of >=i, which is the same as the number of airplanes launched from floors >=i. However, each time a new airplane is added to floor j, it affects all s_i for i <=j. So, the next state would have s_i' = s_i + 1 for i <=j.

But keeping track of s_1 to s_n as part of the state would be O((c)^n) possible states, which is impossible for n=100.

So, this approach is not feasible.

Alternative Idea: Since each s_i must be <=c (because once s_i reaches c, no more airplanes can be added to any floor >=i). Wait, no. Because s_i is the sum of >=i. So, if s_i reaches c, then any airplane added to a floor >=i would increase s_i. But the problem says that once s_i reaches c, the residents of i will not launch anymore. But the same applies to higher floors.

Wait, the resident of floor j can only launch if, before launching, their sum (s_j) is <c. So, after some steps, when s_j reaches c, no more airplanes can be launched from j or higher floors. Wait, no. For example, if you launch from a floor k >j, then s_j would be incremented, but s_k is the sum of >=k, which is separate. So, even if s_j >=c, s_k could be <c, allowing a launch from floor k.

But launching from floor k would increment s_1, s_2, ..., s_k. So, if s_j was already c, adding a higher floor's airplane would push s_j beyond c, which is allowed as long as that higher floor's sum (s_k) was <c before adding.

But the problem states that the sum after all m airplanes must be >=c for each floor. So, s_i >=c for all i. So, after all launches, each s_i is at least c.

But during the process, when adding a airplane to j, s_1 to s_j are incremented. So, the sum for each i <=j increases by 1.

The key constraints are:

1. For each airplane in the sequence, when it is j, before adding it, s_j must be <c. Because the resident j would not launch if s_j (the sum before) >=c.

2. After all m airplanes, for each i, s_i >=c.

So, the problem is to fill the gaps in the sequence, ensuring these two conditions.

Now, how to model this in code?

The main challenge is the state representation. Since n can be up to 100, we cannot track all s_i for each state. However, perhaps we can find a way to represent the state more efficiently.

Alternative Idea: Notice that s_i is the number of airplanes launched from floors >=i. So, s_i = sum_{k >=i} cnt[k], where cnt[k] is the count of airplanes launched from floor k.

But the order of the airplanes matters because each airplane j affects the s_i for all i <=j. But if we have the counts for each floor, can we compute the s_i?

Yes. Because s_i is the sum of cnt[i], cnt[i+1], ..., cnt[n].

So, for a given set of counts cnt[1..n], the s_i can be computed as the suffix sums.

But how does the order affect the validity? Because the constraint for each airplane j is that before adding it, the s_j (sum of >=j at that point) must be <c.

So, the order of adding airplanes affects when each s_j reaches c. Therefore, the order is important.

But modeling the state as the current counts and the current s_i for each i is impossible due to the size.

Alternative Idea: Since the s_i is the suffix sum of cnt, perhaps the counts can be represented in a way that allows us to track the necessary information.

Suppose we track for each floor j, the number of times it has been used so far (cnt[j]). Then, for any airplane j added next, we can compute s_j as the suffix sum from j to n. If this s_j (before adding the new airplane) is >=c, then it's invalid.

But the problem is that for each step, when we add a new airplane to j, it increments cnt[j], and thus affects the s_i for all i <=j.

So, the key constraints during the process are that for any airplane j added at step k, the sum of cnt[j] + cnt[j+1] + ... + cnt[n] (before adding this airplane) must be <c.

But how to model this in a dynamic programming approach?

Let me think of the state as the current counts cnt[1..n]. The transition is adding a new airplane to j, which increments cnt[j] and checks if the sum of cnt[j..n] (before increment) is <c.

But the state is the cnt array, which for n=100 would be 100 dimensions. Not feasible.

Alternative Idea: Since each cnt[j] can be at most c, because once the suffix sum for j reaches c, no more airplanes can be added to j or higher floors. Wait, no. Because adding a higher floor's airplane (e.g., j+1) would require the suffix sum for j+1 (before adding) to be <c, but it doesn't affect the suffix sum for j, except that adding j+1 increments cnt[j+1], which is part of the suffix sum for j. So, even if the suffix sum for j is already c, adding an airplane to j+1 (if allowed) would increase the suffix sum for j, possibly beyond c. But the problem requires that after all m steps, all s_i >=c. So, for example, s_j could be >=c even before the last steps.

But during the process, when adding an airplane to j, we only need to check that the suffix sum for j (before adding) is <c.

So, perhaps the maximum allowed cnt[j] is c, because if the suffix sum for j is already c, then adding another airplane to j would require that before adding, the suffix sum (which includes cnt[j] and others) is <c. But once the suffix sum for j is >=c, adding j is not allowed.

But this seems not directly applicable. Let's think of a scenario. Suppose we have cnt[j] = 0, and all cnt[j+1..n] are c. Then the suffix sum for j is 0 + c*(n-j), which is possibly larger than c. But adding an airplane to j would require that the suffix sum for j (before adding) is <c. But if the suffix sum is already larger than c, then adding j is invalid. So, in such a case, you can't add j.

But how to model this?

This seems very complex. Perhaps we need a different approach.

Alternative Idea: For each floor j, the maximum number of times it can be used is c. Because after adding an airplane to j, the suffix sum for j would increase by 1. If the suffix sum for j (before adding) is s, then s must be <c. So after adding, s becomes s+1. But since the final sum for j (after all m steps) must be >=c, the total number of airplanes added from j or higher floors must be >=c.

Wait, but each airplane added from j contributes to the sum of j. So, the sum of j is the number of airplanes added from j or higher floors. So, the sum of j is the sum of cnt[j] + cnt[j+1] + ... + cnt[n].

So, to have sum[j] >=c, the sum of cnt[j..n] >=c.

But during the process, when adding an airplane to j, the sum of cnt[j..n] (before adding) must be <c, because otherwise the resident j wouldn't have launched.

So, the total sum for j after all steps is the sum after adding all airplanes. For this to be >=c, the sum after adding all airplanes must be >=c, which implies that during the process, the sum[j] (after adding the airplanes) must reach at least c.

But how can this be possible? Because each time you add an airplane to j or higher, the sum[j] increases by 1. So, the sum[j] starts at 0 and each time you add an airplane to >=j, it increases by 1. So, after m steps, the sum[j] must be >=c.

But during the process, each time you add an airplane to j, you must have sum[j] (before adding) <c. So, the sum[j] after adding is sum[j] + 1 <=c.

Wait, sum[j] before adding is <c, so sum[j] after adding is <=c.

But the final sum[j] must be >=c. So, sum[j] after adding must be exactly c. Because if during the process, sum[j] reaches c, then adding any airplanes to >=j would be allowed only if their sum is <c.

Wait, no. For example, sum[j] after adding could be c, and then later airplanes added to j+1 would increase sum[j] to c+1, etc.

Wait, let's take an example.

Suppose c=2. For j=3, sum[j] (sum of cnt[3..n]) starts at 0.

Add airplane to 3: sum[j] becomes 1 (before adding was 0 <c=2). Now sum[j] is 1.

Add airplane to 4: sum[j] (sum of 3 and 4) was 1 (cnt[3]=1, cnt[4]=0) before adding. So adding to 4 would increment cnt[4], sum[j] becomes 1+1=2. After adding, sum[j] is 2.

Now, any further additions to >=3 floors require sum[j] (before adding) <2. But after this step, sum[j] is 2, so adding to 3 would require sum[j] (sum[3..n]) before adding to be <2. If after adding to 4, sum[j] is 2, then adding another airplane to 3 would require sum[j] (before) to be 2, which is >=c. So that's invalid. So no more airplanes can be added to 3 or higher.

But the final sum[j] is 2, which meets the >=c requirement.

But if after adding to 4, sum[j] is 2, and then you add an airplane to 5, which is higher than j=3. Wait, j=5 in this case. So, when adding to 5, you need to check sum[5] (sum of 5..n) before adding. Let's say that sum[5] is 0 (cnt[5] is 0). So adding to 5 is allowed. Then cnt[5] becomes 1, and sum[j=3] is 1 (cnt[3] =1, cnt[4]=1, cnt[5]=1) + any other higher floors. So sum[j=3] would be 1+1+1=3, which is >=c=2. So this is allowed.

But adding to 5 would require that sum[5] (before adding) is <2, which it is (0). After adding, sum[5] becomes 1.

So, the final sum[j=3] is 3, which is >=c=2.

So, the sum[j] can exceed c, but during the process, each addition to a floor j requires that the sum[j] before adding is <c.

But how does this affect the state transitions?

The key is that for each airplane added to j, the sum[j] (sum of j..n) before adding must be <c.

But sum[j] is the sum of cnt[j] + cnt[j+1] + ... + cnt[n]. So, the sum[j] can be tracked as the suffix sum of the cnt array.

But tracking the entire cnt array is not feasible for large n.

Alternative Idea: For each position in the sequence, track the current cnt[j] for each j, but clamped to the maximum value that can contribute to the sum[j] not exceeding c. For example, cnt[j] can't be more than c, because if sum[j] (before adding) is cnt[j] + ... + cnt[n], and sum[j] <c, then after adding j, the new cnt[j] is increased by 1. But sum[j] could be up to c-1 before adding j, so sum[j] after adding is up to c.

But this seems not directly applicable. Let's think again.

Suppose we have a cnt array where cnt[j] is the number of airplanes launched from j. The sum for j is the sum of cnt[j..n]. When adding a new airplane to j, we need sum[j..n] before adding to be <c.

But sum[j..n] = sum_{k>=j} cnt[k] < c.

But after adding, cnt[j] increases by 1, so sum[j..n] becomes sum_{k>=j} cnt[k] +1.

The problem requires that for all j, sum_{k>=j} cnt[k] >=c after all steps.

So, during the process, each time you add an airplane to j, you must ensure that sum_{k>=j} cnt[k] (before adding) <c.

The final sum for each j must be >=c.

But how can we model this in a way that is computationally manageable?

Another Idea: Let's think about the sequence of airplanes in reverse. But I'm not sure.

Alternative Approach: Use memoization with the current step and the counts of each floor, but with some optimizations.

But for n=100 and m=1e4, this is not feasible.

Alternative Idea: Precompute for each floor j, the number of times it must appear in the sequence. But since the order matters, this is not straightforward.

Alternative Idea: Since each addition to j affects all floors <=j, perhaps the key is to track for each j, the number of times floors >=j have been used so far, but clamped to c.

For example, when adding a new airplane to j, the sum of floors >=j must be <c before adding. So, after adding, this sum is increased by 1. Therefore, for j, the maximum allowed sum of floors >=j before adding is c-1.

But if we track for each j the current sum of floors >=j, we can represent the state as an array of these sums. However, for n=100, this is again 100 variables, leading to a state space of O(c^100), which is impossible.

But perhaps there's a way to represent the state more compactly. For example, for each j, the sum of floors >=j is s_j. The s_j can be computed as s_j = s_{j+1} + cnt[j], but this is still not helpful.

Alternative Idea: Since s_1 >= s_2 >= ... >= s_n, because s_j is the sum of floors >=j, which includes s_{j+1} plus cnt[j]. So s_j = s_{j+1} + cnt[j]. Thus, the sequence s_1, s_2, ..., s_n is non-increasing.

But even this property doesn't immediately help in reducing the state space.

Alternative Idea: The sum s_j is the number of airplanes launched from j or higher. So, for each j, s_j = sum_{k >=j} cnt[k]. Since the order of the airplanes is important, but each step must ensure that before adding a plane to j, s_j <c.

But maybe we can model the state using the current s_1, s_2, ..., s_n, but clamped to c. Since once s_j >=c, adding a plane to any k >=j would require that s_k <c. However, once s_j >=c, adding planes to higher floors (k>j) could still be possible if s_k <c.

But even this approach requires tracking all s_j, which is not feasible for n=100.

Alternative Idea: Find that the s_j values are determined by the s_{j+1} and cnt[j]. So, for each j, s_j = s_{j+1} + cnt[j]. This recursive relation could be used to compute the s_j values based on the cnt array.

But how does this help in the DP state?

Perhaps we can track the s_j values in a way that allows us to compute them without storing the entire array. For example, track s_1, and infer the other values. But this is not obvious.

Another Idea: Let's consider the constraints for each airplane in the sequence. For a given step, if the airplane is j, then s_j (before adding) <c. So, the airplane j must be added before the s_j reaches c. After adding, s_j increases by 1. But since s_j is the sum of cnt[j] + s_{j+1}, the cnt[j] can be derived as s_j - s_{j+1}.

But how to model this in the DP.

Wait, perhaps the key is that for each j, the maximum number of airplanes that can be launched from j is c. Because once s_j reaches c, adding more airplanes to j is not allowed. But this is not necessarily true, because adding an airplane to a higher floor j+1 would also contribute to s_j.

But for example, if j=3, and s_j is 2 (c=3), adding a plane to j=4 would increment s_4 by 1, and s_3 by 1 (since s_3 = s_4 + cnt[3]). So, in this case, s_3 would become 3, which is c. So, after adding the plane to j=4, s_3 becomes 3. But this is allowed because the airplane was added to j=4, and during that step, the sum for j=4 (before adding) must be <c.

But the sum for j=3 (after adding) can be >=c.

So, the maximum number of airplanes that can be launched from j is not bounded by c. Because airplanes launched from higher floors can also contribute to s_j.

So, this approach is not directly applicable.

Alternative Idea: Let's think about the problem as a dynamic programming problem where the state is the current position in the sequence and the current suffix sums s_1 to s_n, clamped to c. However, for n=100, this is not feasible.

Alternative Idea: Since the sum s_j is non-increasing (s_1 >= s_2 >= ... >= s_n), we can represent the state as the current position and the current s_j for each j, but track them in a way that takes advantage of their non-increasing nature. But I'm not sure how to do that.

Alternative Idea: Perhaps the problem can be transformed into a combinatorial problem where the number of valid sequences can be determined by considering the order in which certain thresholds are met.

But I'm not sure. For example, each time a s_j reaches c, it affects the possible future choices.

Alternatively, think of the problem as a grid where each step involves choosing a floor j to launch from, subject to the constraints on s_j.

But without a clear way to model this, I'm stuck.

Looking back at the code provided in the previous solution, the code uses a recursive DP approach with the state being the current position and the counts for each floor. For each step, it checks if the current airplane is fixed or a gap, and tries all possible options. The state is the counts for each floor, which is a tuple of size n. The transition is to increment the count for j and check if the sum of >=j is <=c.

But with n=100 and m=1e4, this approach is not feasible. The state space is (m) * (c+1)^n, which is way too large.

So, the previous code works for small n (like the sample inputs), but is not efficient for larger n.

But according to the problem constraints, n can be up to 100, which makes this approach impossible.

So, what's the correct approach here?

Let's think differently. For each floor j, the number of airplanes launched from j must be exactly the number of times j appears in the sequence. Let's denote this as cnt[j]. The constraints are:

1. For each j, the sum_{k >=j} cnt[k] >=c. (Final sum)

2. For each occurrence of j in the sequence, the sum_{k >=j} cnt[k] before that occurrence must be <c. (During the process)

But how to model this.

Another Idea: The sum_{k >=j} cnt[k] is exactly the number of times j or higher floors appear in the sequence up to and including that position.

Wait, no. Because the sum_{k >=j} cnt[k] is the total number of airplanes launched from j or higher floors. Each such airplane contributes to the sum of j's sum.

So, for example, the first airplane in the sequence is j. Then sum_{k >=j} cnt[k] is 1. If the next airplane is j+1, sum_{k >=j} becomes 2.

So, for each airplane in the sequence, when you add j, the sum_{k >=j} increases by 1. But for the current airplane j, before adding it, sum_{k >=j} must be <c.

So, the sum_{k >=j} before adding must be <c. After adding, it's sum_{k >=j} +1.

The final sum_{k >=j} must be >=c.

So, the sum_{k >=j} after all m steps is the total number of airplanes in the sequence launched from >=j.

Let me denote S_j as the final sum for j. Then S_j = sum_{k >=j} cnt[k].

The constraints are:

1. For each j, S_j >=c.

2. For each position i in the sequence where a_i = j, the sum_{k >=j} cnt[k] before adding this a_i must be <c.

But how to model this.

Let's consider that each airplane added to j must have been added before the sum_{k >=j} reaches c. Because once the sum_{k >=j} reaches c, adding any airplane to j or higher floors is not allowed.

But this is not true. For example, adding an airplane to j+1 after the sum_{k >=j} is c-1 would increment the sum for j to c, but the sum for j+1 is sum_{k >=j+1} +1. If sum_{k >=j+1} before adding is c-1 - sum_{k >=j} = sum_{k >=j} = sum_{k =j} + sum_{k >=j+1} }.

This is getting too complicated.

Alternative Idea: For each floor j, the number of airplanes launched from j can be any number, but the first c of them must be launched before the sum of >=j reaches c.

But I'm not sure.

Let me try to model the problem for a single floor j.

For j to have S_j >=c, there must be at least c airplanes launched from >=j. Each time an airplane is launched from >=j, it contributes to S_j.

But during the process, each airplane launched from >=j must have been launched before S_j (before adding) was <c.

So, the first c airplanes launched from >=j must be launched when the sum before adding was 0, 1, ..., c-1. The remaining airplanes can be launched after the sum reaches c, but wait no. Because once the sum before adding is >=c, you can't launch any airplanes from >=j.

So, the total number of airplanes launched from >=j is exactly S_j >=c. But during the process, each airplane launched from >=j must have been launched when the sum before adding was <c.

So, the sum before adding for each such airplane must be 0,1,...,c-1. But how many times can we launch from >=j after the sum reaches c?

No, because once the sum before adding is >=c, you can't launch any more airplanes from >=j. So the total number of airplanes from >=j is exactly S_j, which must be >=c, and each of these S_j airplanes must have been launched when the sum before adding was <c.

Wait, no. Because S_j is the sum of all airplanes from >=j. Each airplane in this sum must have been added when the sum before adding was <c. Because otherwise, the airplane would not have been launched.

So, for each airplane in the sum S_j, the sum before adding was <c. So, the first airplane from >=j increases the sum from 0 to 1. The second from 1 to 2. And so on until the sum before adding is c-1, and the sum after adding is c.

So, the total number of airplanes launched from >=j must be exactly c. Because if you launch more than c, then when adding the (c+1)-th airplane from >=j, the sum before adding would be c, which is >=c, and thus invalid.

Wait, this is a critical insight.

For each j, the total number of airplanes launched from >=j is exactly c. Because you can't have more than c airplanes launched from >=j, since each addition requires the sum before adding to be <c. So, the maximum possible sum for j is c. Because:

- The first airplane added to >=j is added when sum is 0.

- The second when sum is 1.

- ...

- The c-th when sum is c-1, and sum becomes c.

After that, you cannot add any more airplanes to >=j, since the sum before adding would be c, which is >=c.

But wait, this is only true if all airplanes added to >=j are exactly c in total.

But the problem requires that S_j >=c. So, S_j must be exactly c for all j. Because otherwise, if S_j >c, then when adding the airplanes beyond the c-th, the sum before adding would be >=c, which is invalid.

Ah! This is a crucial realization.

For each j, S_j must be exactly c. Because:

- Each airplane added to >=j must have been added when the sum before was <c.

- So, the first airplane increases the sum from 0 to 1.

- The c-th airplane increases the sum from c-1 to c.

- Adding a (c+1)-th airplane would require the sum before adding to be c, which is >=c. Hence, it's invalid.

Therefore, for all j, S_j must equal c.

This simplifies the problem significantly.

Because now, the total sum from >=j for each j is exactly c. Therefore, the total number of airplanes m must be exactly c * n - sum_{j=2 to n} (j-1)*c. Because the sum of S_1 + S_2 + ... + S_n = c + c + ... + c (n times) but this counts each airplane exactly once for each j <= its floor.

Wait, no. Because each airplane launched from floor j contributes to S_1, S_2, ..., S_j. So, the sum of S_1 + S_2 + ... + S_n is equal to the total number of airplanes m multiplied by j, where j is the floor of each airplane. For example, if an airplane is launched from floor j, it contributes 1 to S_1, 1 to S_2, ..., 1 to S_j. So the sum of all S_i is equal to the sum over all airplanes of their floor.

But according to our previous conclusion, each S_i must be exactly c. So, sum_{i=1}^n S_i = sum_{i=1}^n c = n*c.

But sum_{i=1}^n S_i is also equal to the sum over all airplanes of their floor. Because each airplane from floor j contributes 1 to S_1, S_2, ..., S_j, totaling j.

So, sum_{i=1}^n S_i = sum_{j=1}^n (number of airplanes from j) * j = m_1*1 + m_2*2 + ... + m_n*n = sum_{j=1}^n j * m_j, where m_j is the number of airplanes from floor j.

But since sum_{i=1}^n S_i = n*c, we have sum_{j=1}^n j * m_j = n*c.

Also, sum_{j=1}^n m_j = m, the total number of airplanes.

But according to our previous conclusion, each S_j must be exactly c. S_j is the sum of m_j + m_{j+1} + ... + m_n = c.

So, this forms a system of equations:

m_1 + m_2 + ... + m_n = m

m_1 + m_2 + ... + m_n = c

m_2 + ... + m_n = c

...

m_n = c

But this is only possible if c = m_1 = m_2 = ... = m_n, which is impossible unless m = c * n - sum_{j=2}^n (j-1)*c. For example, if n=3, c=2, then:

S_1 = m_1 + m_2 + m_3 = 2

S_2 = m_2 + m_3 = 2

S_3 = m_3 = 2

So, m_3 = 2, m_2 = 0, m_1 = 0. Sum m = 0 + 0 + 2 = 2. But according to the first equation, sum j*m_j = 0*1 + 0*2 + 2*3 = 6 = 3*2 = 6. So it holds.

But in this case, the sum of m_j is 2, which must equal m. So, for this to be possible, m must equal sum_{j=1}^n m_j = sum_{j=1}^n (S_j - S_{j+1}) ). Since S_j = c for all j, S_{j} - S_{j+1} = m_j.

But S_{n} = m_n =c, S_{n-1} = m_{n-1} + m_n = c → m_{n-1} = 0.

Similarly, S_{j} = m_j + S_{j+1} → m_j = S_j - S_{j+1} = c - c =0 for j <n.

So, m_1 = m_2 = ... =m_{n-1} =0, m_n =c. Sum m = c. So for this to hold, m must be c. But the problem allows m to be up to n*c.

So, this indicates that my previous conclusion that S_j must be exactly c is incorrect. There's a mistake in my reasoning.

Where did I go wrong?

Let me re-express S_j. S_j is the sum of airplanes launched from >=j. For each airplane launched from k >=j, it contributes to S_j. But the sum S_j can be greater than c, as long as when each airplane from k >=j was launched, the sum before adding was <c.

But how?

For example, let's take n=3, c=2.

Suppose we have the sequence [3, 3, 3, 3].

Each airplane is from floor 3.

Let's track the sum S_3 (sum >=3):

- First 3: S_3 before is 0 → allowed. S_3 becomes 1.

- Second 3: S_3 before is 1 → allowed. S_3 becomes 2.

- Third 3: S_3 before is 2 → not allowed. Can't launch.

Wait, but the sequence has four 3s. But according to the constraints, after two 3s, S_3 is 2. The third 3 would require S_3 before to be <2. But after two 3s, S_3 is 2. So, third 3 cannot be launched.

Thus, the sequence [3,3,3,3] is invalid. But according to the initial example in the problem statement, the first test case has n=3, c=2, m=4. The sample input is 4 zeros, and the valid sequences include [1,1,3,3], which sums S_3 = 2, S_2=2, S_1=2.

So, in that case, the sum S_3 is 2, which is exactly c.

Thus, the conclusion that S_j must be exactly c seems correct.

But the first test case in the sample input has m=4, which is 4 airplanes. How does this fit?

Because sum j * m_j = 1*2 (two 1s) +3*2 (two 3s) → 2 +6 =8. But sum j * m_j must equal n*c =3*2=6.

Wait, this doesn't add up. So, my previous assumption that S_j must be exactly c is incorrect.

Hmm. This indicates that my earlier reasoning was wrong. Where is the mistake?

Let's re-examine the example:

Sample Input 1:

3 2 4

0 0 0 0

Valid sequences include [1,1,3,3]. Let's compute S_j for each j.

For j=3: airplanes are launched from 3 and 3. So S_3 = 2.

For j=2: airplanes launched from 1,1,3,3. So S_2 = sum of airplanes from >=2: 3,3. But wait, no. S_2 is the sum of airplanes from 2 and 3. But in the sequence, there are no 2's. So S_2 = sum of 3 and 3: 2.

S_1 is sum of all airplanes: 4.

But according to the problem statement, each S_j must be >=c. In this case, S_1=4 >=2, S_2=2 >=2, S_3=2 >=2.

So S_j can be greater than c for some j.

But according to the constraints, during the process, each airplane added to j must have been added when the sum S_j (before adding) was <c.

But in this example, S_1 is 4, but the airplanes added to 1 were added when their sum S_1 was 0 and 1 (before adding).

So, the previous conclusion that S_j must be exactly c is incorrect. Therefore, my reasoning was wrong.

So, what's the correct way to model S_j?

The sum S_j can be any value >=c, but during the process, for each airplane launched from k >=j, the sum S_k before adding must be <c.

But how can S_j end up greater than c?

Let's take the example of j=1, c=2.

Suppose we have two airplanes from j=1 (sum S_1 becomes 2), and then two airplanes from j=3.

Each time you add an airplane to j=3, S_3 before adding must be <c. Let's see:

- Adding the first 3: S_3 before is 0 → allowed. S_3 becomes 1. S_1 increases by 1 (now 3).

- Adding the second 3: S_3 before is 1 → allowed. S_3 becomes 2. S_1 becomes 4.

Thus, S_1 =4 >=c=2.

So, the sum S_j can be greater than c as long as the airplanes are launched from higher floors.

Thus, the sum S_j for j can be greater than c, but all airplanes launched from >=j must have been added when their own S_k was <c.

So, the key is that when adding an airplane to k, the sum S_k before adding must be <c. This allows higher floors to contribute to the sum of lower floors, but without violating the constraints of their own sum.

Thus, the problem is more complex than previously thought.

So, the correct approach must model the sum S_j for each j, which can exceed c, but ensure that for each airplane launched from k, S_k before adding was <c.

But how to track this for large n.

Alternative Idea: For each position in the sequence, track for each j the current sum S_j. But this is impossible for n=100.

Alternative Idea: For each j, track how many times floors >=j have been used so far. Since S_j is the count of airplanes from floors >=j, this is equivalent to the sum.

But again, this is O(n) state variables.

But perhaps there's a way to represent the state as a tuple of the current S_j for each j, but with some optimizations.

But even for n=100, this is not feasible.

Alternative Idea: Notice that S_1 >= S_2 >= ... >= S_n. So, the state can be represented as a non-increasing sequence. But even with this, for n=100, it's still too many possibilities.

Alternative Idea: For each step, the current S_j can be represented by the count of floors >=j. But I'm not sure.

Alternative Idea: Let's model the problem in terms of the available floors that can still launch airplanes. For example, once S_j reaches c, any airplane added to j must have been added before S_j >=c.

But this seems not helpful.

Another Idea: Think of the problem as a grid where each airplane launch must come from a floor j where the current S_j is less than c. When you choose j, you increment all S_1 to S_j. But for n=100 and m=1e4, this is O(m * c^n), which is not feasible.

But given that the constraints in the sample code use memoization with the counts for each floor, perhaps the correct approach is to model the state as the counts for each floor, and the current S_j can be computed as the suffix sum.

But how to optimize this for large n.

But the sample code uses a recursive DP approach with the counts for each floor. For each position in the sequence, it tries all possible floors (if it's a gap) and checks if adding that floor is valid by computing the current suffix sum.

But with n=100, this approach is not feasible. However, perhaps there's a way to optimize this using memoization with the current counts, but pruning impossible states.

Alternatively, we can represent the state in terms of the current suffix sums, but for n=100, this is impossible.

But the problem constraints might allow for certain optimizations.

Let me think about the constraints again:

Each airplane added to j must have S_j before adding <c. So, the sum of floors >=j before adding is <c.

But S_j is the sum of cnt[j] + cnt[j+1] + ... + cnt[n].

So, for the current step, if the current airplane is j, then cnt[j] + ... + cnt[n] <c before adding.

But after adding, cnt[j] increases by 1, so the new sum is (cnt[j]+1) + cnt[j+1] + ... + cnt[n] = S_j_new = S_j_prev +1.

But how to track this.

Alternative Idea: Since the problem requires that after all m steps, S_j >=c for all j, but during the steps, adding j requires S_j_prev <c, perhaps the only way to satisfy this is that the sum S_j_prev for each j must be exactly c-1 when the last airplane contributing to S_j is added.

But I'm not sure.

Alternatively, the problem can be viewed as a system of constraints on the sequence of j's:

- For each j, the number of airplanes in the sequence from >=j is at least c.

- For each occurrence of j in the sequence, the number of airplanes from >=j before that occurrence is less than c.

But how to model this.

Another Idea: For each j, the first c airplanes in the sequence that contribute to S_j (i.e., are from >=j) must be placed in such a way that before each of them is placed, the count of such airplanes so far is less than c.

The remaining airplanes can be placed anywhere as long as they don't require S_j_prev <c.

But no, because any airplane from >=j contributes to S_j, and each such airplane must have S_j_prev <c.

Thus, the total number of airplanes from >=j can be any number >=c, but each of these must be added when the current count is <c.

But this is only possible if exactly c airplanes are from >=j, because once you have c airplanes from >=j, the next one would require S_j_prev =c, which is invalid.

Thus, the only way to have S_j >=c is to have exactly c airplanes from >=j. So, S_j =c.

But in the sample input, S_1 =4, which is greater than c=2. So, this contradicts this conclusion.

So, I must have made a mistake here.

Let's re-examine the sample input 1:

Sample Input 1:

3 2 4

0 0 0 0

Valid sequences include [1,1,3,3].

Let's compute S_j for each j:

- S_3: number of airplanes from >=3 → 2 (two 3's). So S_3=2 =c.

- S_2: number of airplanes from >=2 → two 3's. So S_2=2 =c.

- S_1: number of airplanes from >=1 → all four airplanes. So S_1=4 >=c.

But according to the previous reasoning, S_1 must be exactly c. But in this case, it's 4. So, this invalidates the previous conclusion.

So, where is the mistake?

The mistake is in assuming that all airplanes contributing to S_j must be added when S_j_prev <c. However, S_j_prev refers to the sum before adding the airplane. For example, when an airplane is added to j=1, it increases S_1, S_2, ..., S_j. But when adding an airplane to j=3, it increases S_1, S_2, S_3.

So, in the sample input:

The sequence [1,1,3,3].

- First 1: S_1=0, S_2=0, S_3=0.

After adding: S_1=1, S_2=1, S_3=1.

- Second 1: S_1=1 (before adding) <2. So valid. After adding: S_1=2, S_2=2, S_3=2.

- First 3: S_3=2 (before adding) >=2 → invalid. But the sample says it's valid. Wait, this contradicts the problem statement.

Wait, this indicates that my understanding is wrong.

Wait, when adding the first 3, the sum S_3 (before adding) is 2. Which is >=c=2. So the resident 3 would not launch. But in the sample sequence, this is considered valid. So this is a problem.

But according to the sample explanation, [1,1,3,3] is a valid sequence. But according to the constraints, when adding the first 3, the sum S_3 before adding is 2 (from the two 1's and the two 1's would have contributed to S_3? No. Wait, the airplanes from 1 do not contribute to S_3. Only airplanes from 3 contribute to S_3. Wait, no: S_j is the sum of airplanes from >=j.

So, for S_3, it's the sum of airplanes from 3.

In the sequence [1,1,3,3], the first two airplanes are from 1. So for S_3, before adding the first 3, the sum is 0. Because no airplanes from >=3 have been launched yet.

Ah! I see my mistake.

S_j is the sum of airplanes from >=j. So, for j=3, S_3 is the sum of airplanes from 3.

In the sequence [1,1,3,3], the first two are from 1. So before the third element (first 3), the sum for S_3 is 0. So adding the 3 is allowed. After adding, S_3 becomes 1.

Then adding the fourth element (second 3), S_3 before adding is 1 <c=2. After adding, S_3 is 2.

Thus, S_1 after four steps is 4 (from two 1's and two 3's). S_2 is 2 (from two 3's). S_3 is 2.

So, S_1=4 >=c=2, S_2=2 >=c, S_3=2 >=c.

Thus, the key is that when you add an airplane to j, it contributes to S_1, S_2, ..., S_j. So, S_j is the sum of airplanes from >=j, which includes airplanes from j, j+1, ..., n.

So, my earlier mistake was in thinking that S_j is the sum of airplanes from j only. No, S_j is the sum of airplanes from j, j+1, ..., n.

Thus, when you add an airplane to j, it increments S_1, S_2, ..., S_j.

This changes everything.

So, S_j is the number of airplanes launched from floors j, j+1, ..., n.

Thus, when you add an airplane to j, it increases all S_1 to S_j by 1.

Therefore, the state is not just the counts for each floor, but the entire S_1 to S_j values.

But this makes the problem even more complex.

But how to model this.

Alternative Idea: The sum S_j can be computed as the sum of S_{j+1} plus the count of airplanes launched from j.

But this recursive relation allows us to compute S_j based on S_{j+1} and the count of j.

But even this doesn't immediately help in modeling the state.

Another Idea: Let's think of the state as the current S_1, S_2, ..., S_n. Since S_1 >= S_2 >= ... >= S_n >=0, and each S_j <=m.

But for n=100 and m=1e4, this is impossible.

Alternative Idea: But when adding an airplane to j, the new S_1 becomes S_1_prev +1, S_2_prev +1, ..., S_j_prev +1. S_{j+1} ... S_n remain the same.

This allows us to model the state transitions, but the state is still too large.

But given the problem constraints, it's not feasible.

Thus, the problem requires a different approach, possibly involving combinatorial mathematics.

Alternative Idea: For each j, the number of airplanes launched from j must be such that S_j >=c. But S_j is the sum of airplanes from j to n.

But how to model the order.

Another Idea: The problem is similar to a multi-dimensional knapsack problem where each step adds to multiple dimensions. But this doesn't immediately lead to a solution.

Given the time constraints and the need to provide a correct and efficient solution, perhaps the correct approach is to model the state using the current counts for each floor and memoize the DP with pruning for impossible states.

But for the given sample inputs, this approach works.

The previous code provided uses this approach but with memoization of the counts for each floor. However, this approach is not efficient for large n. But given the problem constraints (n up to 100, m up to 1e4, and t up to 1e4 with sum of m across test cases up to 1e4), it's likely that the intended solution uses this approach with optimizations.

But how to optimize this.

Optimization Idea: Since the sum S_j must be >=c for all j, we can prune states where any S_j is already >=c and there are still positions to fill. Because adding more airplanes can only increase S_j, but the final S_j must be >=c. So, if S_j is already >=c and there are no more positions, it's valid. But during the process, as long as the current S_j is >=c and there are remaining steps, it's possible to add airplanes to lower floors.

But this is not helpful for pruning.

Alternative Optimization: For each floor j, the count of airplanes launched from j cannot exceed c. Because when you launch an airplane from j, you increase S_j by 1, and S_j must be <c before adding. So, the maximum number of airplanes from j is c. Because after c airplanes, S_j would be c, and adding another would require S_j_prev =c, which is invalid.

But this is not true, because S_j is also increased by airplanes from higher floors. For example, launching an airplane from j+1 increases S_j by 1. So, even if you launch zero airplanes from j, S_j can be increased by airplanes from higher floors.

Thus, the maximum number of airplanes from j is not limited to c.

Thus, the previous optimization is invalid.

Given the time constraints, the correct solution is to proceed with the initial approach, even though it may not be efficient for large n. However, given the problem's constraints (n up to 100 and m up to 1e4), this approach may not be feasible, but perhaps the intended solution is as follows:

The code uses memoization with the current counts for each floor. However, for each step, instead of tracking the entire counts array, track the clamped counts (up to c) for each floor. Because once the sum for j (S_j) reaches c, adding more airplanes from higher floors does not affect the possibility of adding airplanes to j, as their sum before adding is already >=c.

Wait, but if S_j is clamped to c, then the counts for j can be represented as min(count[j], c). But this is not directly applicable.

But considering that when S_j >=c, adding airplanes to j is not allowed. But adding airplanes to higher floors would still affect S_j.

But perhaps, for the purpose of checking the constraints, we can clamp the sum S_j to c, since any value >=c is treated the same way (no more airplanes can be added to j).

But this is not accurate, because even if S_j is clamped, adding airplanes to higher floors will still increase S_j beyond c.

Thus, this approach is not correct.

Given that I'm stuck and need to provide a solution, I'll proceed with the initial code but optimize it by clamping the counts to c.

Here's the revised code:

```python
import sys
from functools import lru_cache

MOD = 10**9 + 7

def main():
    input = sys.stdin.read().split()
    ptr = 0
    t = int(input[ptr])
    ptr += 1
    for _ in range(t):
        n, c, m = map(int, input[ptr:ptr+3])
        ptr +=3
        a = list(map(int, input[ptr:ptr+m]))
        ptr +=m
        
        fixed = []
        possible = True
        for num in a:
            if num == 0:
                fixed.append(None)
            else:
                if num < 1 or num > n:
                    possible = False
                fixed.append(num - 1)  # Convert to 0-based
        
        if not possible:
            print(0)
            continue
        
        # We need to clamp the counts to c, because once a floor's suffix sum reaches c, adding more to higher floors won't affect the validity
        # Precompute the clamped counts
        # Also, we can track the suffix sums for each floor
        # To compute the suffix sum for j, we can use the clamped counts and calculate the sum from j to n, but clamped to c
        
        @lru_cache(maxsize=None)
        def dp(pos, *counts):
            # counts is a tuple where counts[j] is the number of airplanes from floor j+1 (0-based)
            # Wait, need to adjust the indices
            # Convert counts to a list where counts[j] is for floor j (0-based)
            counts = list(counts)
            # Compute suffix sums
            suffix = [0]*(n+1)  # suffix[j] is sum from j to n-1
            for j in range(n-1, -1, -1):
                suffix[j] = min(counts[j] + suffix[j+1], c)
            # Check if we have reached the end
            if pos == m:
                # All suffix sums must be >=c
                for j in range(n):
                    if suffix[j] < c:
                        return 0
                return 1
            # Check if the current position is fixed
            current = fixed[pos]
            if current is not None:
                j = current
                # Check if the suffix sum for j is <c before adding
                if suffix[j] >= c:
                    return 0
                # Clone the counts and update
                new_counts = counts.copy()
                new_counts[j] +=1
                new_counts = tuple(new_counts)
                # Clamp the counts to c
                for jj in range(n):
                    if new_counts[jj] > c:
                        new_counts[jj] = c
                return dp(pos +1, *new_counts)
            else:
                total = 0
                for j in range(n):
                    if suffix[j] >= c:
                        continue
                    # Compute new counts
                    new_counts = counts.copy()
                    new_counts[j] +=1
                    # Clamp counts to c
                    for jj in range(n):
                        if new_counts[jj] > c:
                            new_counts[jj] = c
                    new_counts = tuple(new_counts)
                    total += dp(pos +1, *new_counts)
                    total %= MOD
                return total % MOD
        
        initial_counts = tuple([0]*n)
        result = dp(0, *initial_counts)
        print(result % MOD)

if __name__ == '__main__':
    main()
```

But this code may not handle clamping correctly. The idea is to track the counts for each floor, but clamp them to c to reduce the state space. However, this is an approximation and may not work correctly. But given the time constraints and the problem's complexity, this is the best I can offer.