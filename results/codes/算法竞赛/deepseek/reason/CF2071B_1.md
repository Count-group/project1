Okay, let's see. I need to find a permutation of length n such that for each i from 1 to n, the sum of the first i elements is not a perfect square. If it's not possible, return -1. 

First, let's think about when it's possible. The sample input shows that for n=1, the answer is -1 because the only possible permutation is [1], and sum is 1 which is a square. For n=4, the answer exists, like 2 4 1 3. For n=5, there's a solution as well.

So the first thing I notice is that n=1 is impossible. What about other values of n?

Let me think about small n values. Let's list possible n and see if they can have a solution.

n=1: sum is 1, which is a square. So no solution. Output -1.

n=2: possible permutations are [1,2] and [2,1]. Check each:

For [1,2]:
sum1=1 (square) → invalid.
So this permutation is invalid.

For [2,1]:
sum1=2 (not square). sum2=3 (not square). So this is valid. So for n=2, the permutation [2,1] is valid. So output exists.

Wait but the sample input for n=4 works. So maybe even numbers can have solutions. But the sample for n=4 is allowed.

Wait, but according to the sample input, when n=4 the output is possible. So why isn't n=2 possible? Because according to the sample, when the user enters 4, the output is possible. Wait, no. Wait the sample input for k=4, which probably represents n=4. So in the sample, for n=4, there is a solution. So n=2 must also have a solution. Let's check.

Wait for n=2, the possible permutations are [1,2] and [2,1].

[2,1] gives sum1=2 (not square), sum2=3 (not square). So that's valid. So output for n=2 is possible. So why isn't there a sample case for that? Oh, the sample input is 3 cases, which are 1,4,5. So perhaps for even n >=2, it's possible? Or maybe not. Let's see for n=3.

For n=3, possible permutations. Let's see if any permutation works.

Let's try to find a permutation. For example:

Let's try permutation [3,1,2].

Sum1:3 → not square.

Sum2:3+1=4 → which is a square (2^2). So invalid.

Another permutation: [2,3,1].

Sum1:2 (ok). Sum2:5 (ok). Sum3:6 (ok). So this works. Wait, sum3 is 2+3+1=6, not a square. So [2,3,1] is valid. So for n=3, possible. So why for some n, there's a solution.

So the question is, for which n does a solution exist? What's the pattern here?

Let's think about when a permutation can't exist.

The main constraint is that for every prefix sum, it's not a perfect square.

But how to arrange the elements so that all prefix sums are non-squares.

The sum of the first i elements is the sum of i distinct numbers from 1 to n. The sum for i elements is (i*(i+1))/2 if it's a permutation of 1..i. But since the permutation can be any arrangement, the sum can vary. Wait, no. Wait, the permutation is of 1..n. So the sum of the first i elements is the sum of i distinct numbers from 1 to n. Wait, but any i elements in the permutation (the first i) must be distinct and from 1 to n. So the sum could be any possible sum of i distinct numbers, but the permutation is a rearrangement. Wait, but the sum of the first i elements is the sum of the first i elements in the permutation. So they are i distinct numbers. So the sum can be any possible sum of i distinct numbers from 1 to n. However, since the permutation is of all numbers, the sum of the entire permutation is fixed as n(n+1)/2. But for each i, the sum of the first i elements is some subset of the permutation's elements. Wait no. The first i elements in the permutation are i distinct elements, but not necessarily the first i numbers. So their sum can vary.

But maybe for some i, the sum of the first i elements must be a square, no matter how you arrange the permutation. Then, such n would have no solution.

For example, n=1: sum is 1, which is a square. So no solution.

What about n=3? Let's see. The sum of the entire permutation is 6. So the sum for i=3 is 6. Which is not a square (since 2^2=4, 3^2=9). So 6 is not a square. So for i=3, the sum is not a square. The problem is with i=1 and i=2.

In the example for n=3, permutation [2,3,1], sum1=2 (ok), sum2=5 (ok), sum3=6 (ok). So works.

So for n=3, possible.

So perhaps the answer exists for all n except n=1?

Wait, but wait. Let's check n=4.

Sample input for n=4: sum1=2 (not square), sum2=6 (not square), sum3=7 (not square), sum4=10 (not square). So yes.

But is there any n where it's impossible to arrange such a permutation?

Wait, perhaps when the sum of the entire permutation is a perfect square? Then for i=n, sum is square, so the permutation can't exist. So for example, if n(n+1)/2 is a square, then the permutation can't exist.

Wait, but in that case, even if all other prefixes are okay, the last sum would be a square, so the permutation is invalid.

So for such n, the answer is -1.

So for example, let's see when n(n+1)/2 is a perfect square.

Known solutions for this equation are called square triangular numbers. The values of n that satisfy this are 0, 1, 8, 49, etc. For example:

n=0: sum is 0 (0^2).

n=1: sum is 1 (1^2). So n=1 is invalid.

n=8: sum is 36 (6^2). So n=8 is invalid.

n=49: sum is 49*50/2 = 1225 → 35^2. So for n=49, sum is 35^2. So permutation would have to have sum_i for i=49 equal to 35^2, which is a square. So no permutation is possible for n=49.

So in these cases, the answer is -1.

But wait, the sum of the entire permutation is fixed, so if that's a square, then regardless of the permutation, the last element's sum is a square. So for any permutation of n where sum is a square, output is -1.

So the problem reduces to:

If n is such that n(n+1)/2 is a perfect square, then output -1. Otherwise, construct a permutation where all prefix sums are not squares.

So the first step is to check whether the sum of the permutation (n(n+1)/2) is a square. If yes, output -1.

But for other cases, we need to construct a permutation.

But how?

The sample input for n=4: sum is 10, which is not a square. So possible.

The sample input for n=5: sum is 15, not a square. So possible.

But how to arrange the permutation?

We need to arrange the elements such that for each i from 1 to n, the sum of the first i elements is not a square.

One possible approach is to reverse the permutation. For example, in the sample input for n=5, the permutation is [5,1,4,3,2]. Let's see:

Sum1:5 → not square.

Sum2:5+1=6 → not.

Sum3:6+4=10 → not.

Sum4:10+3=13 → no.

Sum5:13+2=15 → no.

So that works.

But why does reversing work? Let's check for n=2 reversed: [2,1]. Sum1=2, sum2=3. Both non-squares. So works.

For n=3 reversed: [3,2,1]. Sum1=3, sum2=5, sum3=6. All non-squares. So this works.

But wait, let's check sum2=3+2=5 (ok), sum3=6 (ok). So this permutation is valid.

Similarly, for n=4 reversed: [4,3,2,1]. Sum1=4 (not square), sum2=7, sum3=9. Oh wait, sum3 is 9, which is a square. So that's invalid. So reversing doesn't work for n=4.

So in the sample input for n=4, they have [2,4,1,3]. So the approach of reversing works in some cases but not all.

Hmm. So we need a different approach.

Another idea: swap elements such that the first element is as large as possible, to make the sum not a square. For example, in the sample for n=4, the first element is 2. Why not start with 4? Because sum1=4 is not a square, but then the next elements need to be arranged.

Wait, let's see. Suppose for n=4, the permutation is [4,3,2,1]. Then sum1=4 (ok), sum2=7 (ok), sum3=9 (problem), sum4=10 (ok). So sum3 is 9, which is a square. So invalid. So reversing for n=4 doesn't work.

So the sample uses a different permutation: [2,4,1,3]. Let's check the sums:

sum1=2 → ok.

sum2=6 → ok (6 not square).

sum3=7 → ok.

sum4=10 → ok.

So all are non-squares.

So how was this permutation constructed? Let's see:

The first element is 2. Then adding 4 (sum 6). Then 1 (sum 7), then 3 (sum 10). The key is to ensure that each step's sum is not a square.

So the question is, how to arrange the elements such that all prefix sums are non-squares.

But how to do this efficiently for any n (except those where sum is square)?

An alternative approach is to reverse the permutation except for certain elements. For example, in cases where the sum of the first i elements could be a square, rearrange the elements to avoid that.

But this seems tricky. Another idea is to place the largest element first. Let's test for n=4. If we start with 4, sum is 4 (ok). Then next element is 3: sum 7 (ok). Then 1: sum 8 (ok). Then 2: sum 10 (ok). So permutation [4,3,1,2]. Sums are 4,7,8,10. All are non-squares. So this is a valid permutation. So why wasn't this used in the sample? Because the sample provided another possible permutation.

So, perhaps a strategy of placing the largest possible elements first can work. Let's try for n=4.

But why is that approach working? Let's see.

For n=5, if we reverse, the permutation is [5,4,3,2,1]. Let's check the sums:

sum1=5 → ok.

sum2=9 → which is 3^2. So invalid. So permutation is invalid.

So in this case, the reversed approach would fail. So the sample uses a different permutation, starting with 5, then 1, etc.

So the problem is that for some n, reversing the permutation works, and for others, it doesn't.

So the key is to find a permutation where each step's sum is not a square.

But how?

An alternative approach is to place elements in such a way that the prefix sums are as small as possible, but avoiding squares.

Wait, maybe the minimal possible sum for i elements is 1+2+...+i = i(i+1)/2, and the maximum possible sum is n + (n-1) + ... + (n-i+1) = i*(2n -i +1)/2. So the sum of the first i elements can vary between these two values.

But how to arrange the elements such that none of these sums are perfect squares.

Another idea: the sum after each step must be between 1 and the total sum, but avoiding squares.

But the problem is how to arrange the permutation to achieve this.

Alternatively, think of the problem as building the permutation step by step. For each i, choose the next element such that the current sum is not a square. But this seems computationally heavy, but perhaps there's a pattern.

Wait, but for large n (like up to 1e9), we need an O(1) approach. But in the problem statement, the input is k (n), and for each test case, output a permutation. So the code must generate a permutation quickly.

But how? For n up to 1e9, constructing the permutation in O(n) time would be impossible. So there must be a pattern or a way to generate the permutation without iterating through all elements.

Wait, but the problem allows any permutation as long as all prefix sums are not squares. So perhaps there's a pattern that works for all n except when the sum is a square.

So perhaps the approach is:

If the sum (n(n+1)/2) is a square, output -1.

Else, output a permutation that is the reverse of the natural order. But when does this work?

As we saw for n=4, reverse doesn't work, but for n=5, a modified reverse (like putting 5 first, then 1, then 4, etc.) worked.

Alternatively, perhaps the correct approach is to reverse the permutation except for the first element. Or maybe swap the first two elements.

Wait, let's see for n=4. The reversed permutation is [4,3,2,1], which gives sum3=4+3+2=9, which is a square. So to fix that, swap the third element with another. For example, [4,3,1,2]. Sum3 is 8, which is not a square.

So the key is to avoid the sum after i steps being a square.

But how to do this in general.

Alternatively, perhaps for even n, a certain pattern works, and for odd n, another.

Alternatively, here's a possible pattern: For n >=2, except when sum is a square, arrange the permutation as:

If n is even: arrange even numbers first in decreasing order, then odd numbers in decreasing order. Or some similar pattern.

Alternatively, another approach: the sum after each step is the maximum possible for the first i elements, except for certain swaps to avoid squares.

For example, the maximum possible sum after i steps is (n) + (n-1) + ... + (n-i+1) = sum from k = n-i+1 to n of k = i*(2n -i +1)/2.

If this sum is not a square for any i, then the reversed permutation would work. But for some i, this sum could be a square, which would require modifying the permutation.

But how to know which i would cause a problem.

Alternatively, perhaps the reversed permutation works for all n except when the sum of the first i elements (in reversed order) is a square.

But how to check that.

But for large n, even checking all i up to n is impossible. So this approach is not feasible.

Hmm.

Alternative idea: Let's consider that when the permutation is reversed (arranged in decreasing order), the sum of the first i elements is as large as possible. So perhaps this sum is less than the next square, avoiding the problem.

Wait, but for example, for n=4, the sum of the first 3 elements is 4+3+2=9, which is exactly 3^2. So in this case, the reversed permutation is invalid.

But if we swap the third element (2) with another element (like 1), then the sum of the first 3 elements becomes 4+3+1=8, which is not a square.

So the approach could be: reverse the permutation, but if any prefix sum is a square, swap the i-th element with another element (like the last one) to avoid the square.

But how to do this systematically.

Alternatively, here's a possible pattern: arrange all elements except one in reverse order, and place a certain element in the first position.

But this is vague.

Wait, let's think about the sum of the first i elements in reversed order. For reversed permutation [n, n-1, ..., 1], the sum of the first i elements is sum_{k=0}^{i-1} (n -k) = i * (2n -i +1)/2.

We need to check whether this sum is a square for any i.

If not, then the reversed permutation works. Else, we need to modify it.

But for large n, this is not feasible to check for all i.

Alternatively, perhaps the only case where the reversed permutation has a square sum is when i=1 (sum is n) is a square. But for n=4, the sum for i=3 is 9, which is square.

So the reversed permutation can have multiple i where sum is square.

But how to avoid that.

Alternative approach: arrange the permutation as [n, 1, 2, 3, ..., n-1]. Wait, but that's not a permutation. Wait, no. For example, for n=5: [5,1,2,3,4]. Let's check the sums:

sum1=5 (ok).

sum2=5+1=6 (ok).

sum3=6+2=8 (ok).

sum4=8+3=11 (ok).

sum5=11+4=15 (ok). So all sums are non-squares. So this permutation works.

So this arrangement would work for n=5.

But for n=4: [4,1,2,3]. Sum1=4 (ok).

sum2=5 (ok).

sum3=7 (ok).

sum4=10 (ok). So works.

So why does this arrangement work?

Because the first element is n, then followed by 1, 2, 3, ..., n-1.

Let me check for i=3 in n=4: sum3 is 4+1+2=7 (not square).

So this arrangement works.

Let's check for i=3 in n=5: sum3 is 5+1+2=8 (ok).

Similarly for other i's.

So the sum after the first element is n, then adding 1, 2, etc. So the sum after i elements (i>=2) is n + sum_{k=1}^{i-1} k.

Sum for i elements (i>=2):

sum = n + (i-1)*i / 2.

We need to check if this is a perfect square.

So for the arrangement [n, 1, 2, 3, ..., n-1], the sum for i elements is:

i=1 → n.

i>1 → n + (i-1)*i/2.

We need to ensure that none of these sums are perfect squares.

Let's see for n=5:

i=1: 5 (not square).

i=2:5+1=6 → not.

i=3:5+3=8 → not.

i=4:5+6=11 → not.

i=5:5+10=15 → not.

All non-squares. So works.

n=4:

i=1:4 → not.

i=2:4+1=5 → not.

i=3:4+3=7 → not.

i=4:4+6=10 → not.

All good.

n=3:

i=1:3 → not.

i=2:3+1=4 → which is a square. So invalid.

Ah, here's a problem. For n=3, this arrangement would fail at i=2. So sum is 4.

So this arrangement works for some n but not others.

Hmm. So need another approach.

Wait, but in the case of n=3, the arrangement [3,1,2] is invalid because sum2 is 4. So another permutation is needed. Like [2,3,1], which works.

So the problem is that for some n, the arrangement [n, 1, 2, ..., n-1] fails.

So how can we adjust this?

Another idea: swap the second element with the last element. For example, in n=3, the arrangement [3, 2, 1] is reversed, which gives sum2=5 (ok). So perhaps the reversed permutation works except when the sum of the first i elements is a square.

But for n=3 reversed, the sum3 is 6 (ok), sum2 is 5 (ok), sum1 is 3 (ok). So reversed permutation works for n=3.

But earlier when we tried reversed permutation for n=4, sum3 was 9 (problem). So for reversed permutation, sum3 is 9 for n=4, which is a square.

So the reversed permutation works for some n, but not others.

So the pattern is not straightforward.

Alternative approach: Let's think of the sum of the first i elements. For the reversed permutation, the sum is i*(2n -i +1)/2. We need to check if this is a square for any i in 1..n.

If not, then reversed permutation is valid. Else, need to modify the permutation.

But how to check for all i efficiently.

But for large n, this is not feasible. So there must be a general pattern.

Alternatively, perhaps the sum i*(2n -i +1)/2 is a square only in certain cases, and those cases can be avoided by modifying the permutation.

But I'm not sure.

Alternatively, let's think of the following construction:

If the sum of the first element is a square (n is a square), then we can't have the first element as n. So we need to swap it with another element.

But if n is a square, then sum1 =n would be a square. So in this case, we can't have the first element as n. So we can swap the first element with another element, say the second, to make sum1 non-square.

For example, n=4: 4 is a square (2^2). So reversed permutation starts with 4, which is sum1=4 (square). So invalid. So in this case, we can swap first element with 2, giving [2,3,4,1]. Let's check:

sum1=2 (not square).

sum2=2+3=5 (not square).

sum3=5+4=9 (square). Oh no, invalid.

So this permutation fails.

Hmm. So even after swapping, it's possible to get another sum that's a square.

Another idea: For n=4, perhaps arrange the permutation as [2,4,1,3], as in the sample. The sum for i=3 is 7 (non-square). So how to generate such a permutation.

But how to find a general way to construct such permutations.

Alternative approach:

If the sum of the entire permutation is not a square (which is necessary for a solution to exist), then perhaps the following construction works:

Place the elements in reverse order, except swap the first two elements.

So for example, n=4: reversed is [4,3,2,1]. Swap first two elements to get [3,4,2,1].

Check sum:

sum1=3 → not square.

sum2=3+4=7 → not.

sum3=7+2=9 → square. Oh no.

So invalid.

Hmm.

Alternatively, swap the first element with the last element. For n=4: [1,3,2,4]. Sum1=1 (square). No good.

Alternative idea: For reversed permutation, check if any sum is a square. If so, swap the element at that position with another to break the square.

But again, for large n, this is not feasible.

Perhaps there's a way to arrange the permutation such that the sum of the first i elements is always between two consecutive squares. But how.

Alternatively, here's another observation: for the sum of the first i elements, if i is 1, the sum is the first element. So to avoid sum1 being a square, the first element should not be a square. So for example, if n is a square, then we can't have the first element as n. So in that case, swap it with another element.

But for example, n=4 is a square. So first element can't be 4. So we can have first element as 2, then 4, then 1, then 3. Like the sample.

But how to generalize this.

Another idea: arrange the permutation such that the first element is the largest non-square number possible. For example, if n is a square, then choose the largest possible element less than n that is not a square. But this requires checking which elements are squares.

But for large n, this can be tricky.

Alternatively, the first element is 2. Then the rest are in reverse order. Let's see for n=4:

Permutation [2,4,3,1].

Sum1=2 (ok).

sum2=6 (ok).

sum3=9 (square). Oh no.

Hmm. So again, problem.

But the sample uses [2,4,1,3]. Sum3=7 (ok).

So perhaps the key is to arrange the first two elements as non-squares, then the rest in a way that avoids square sums.

But this is getting complicated.

Alternative approach inspired by the sample for n=4:

The sample permutation is [2,4,1,3]. The first element is 2 (not square), then 4 (sum 6), then 1 (sum 7), then 3 (sum 10).

So the idea is to place the next element in such a way that the sum doesn't form a square. But how to generalize this.

Alternatively, perhaps the following steps can be followed:

1. Check if the sum of the permutation (n*(n+1)/2) is a square. If yes, output -1.

2. Else, construct the permutation as follows:

   a. Start with the largest element (n) as the first element. Check if it's a square. If not, proceed. If it is a square, swap it with the next element.

   b. Then add the next elements in reverse order, but checking if adding them would cause the sum to be a square. If yes, swap with another element.

But this seems ad-hoc.

Alternatively, perhaps the following approach works:

Arrange the permutation as follows:

- The first element is n.

- The remaining elements are arranged in reverse order (n-1, n-2, ..., 1).

Then check the sum of each prefix. If any sum is a square, swap the elements in such a way to break that sum.

But again, this requires knowing which positions are problematic.

But for large n, this is not feasible.

Another idea: When n is not a square, the first element is n. The sum after each step is n + sum_{k=1}^{i-1} (n- k) for i >=2.

Wait, sum of first i elements when arranged as [n, n-1, n-2, ..., 1] is sum_{k=0}^{i-1} (n -k) = i*(2n -i +1)/2. So for each i, we need to check whether i*(2n -i +1)/2 is a square.

But for large n, this is not feasible.

But perhaps the only i for which this sum can be a square is i=1 (sum is n, which is a square only if n is a square). So if n is not a square, then the reversed permutation is valid. But this is not the case, as seen in n=4 (sum3=9).

But n=4 is a square (2^2), so the first element is 4 (sum1=4, square). So reversed permutation is invalid.

But if n is not a square, but reversed permutation has a sum for some i>1 that's a square, then this approach won't work.

Hmm.

Another observation: the sum of the first i elements in reversed permutation is i*(2n -i +1)/2.

We need to find if any of these sums is a square.

But solving for i in this equation is not trivial.

For example, in the case of n=4, i=3:

sum = 3*(2*4 -3 +1)/2 = 3*(8-3+1)/2 = 3*(6)/2 = 9. Which is 3^2.

So for n=4, the sum for i=3 is a square.

Thus, the reversed permutation is invalid.

But how to avoid this.

So the problem is to construct a permutation where the sum of the first i elements is not a square for any i. For n=4, the sample shows that such a permutation exists. So there must be a way.

But how to find a general way to construct it.

Perhaps the following pattern works for all n where the sum is not a square:

If n is even, place all even numbers first in reverse order, then odd numbers in reverse order.

Or some other similar pattern.

But this is just a guess.

Alternatively, for n=5, the sample uses [5,1,4,3,2]. Sums are 5,6,10,13,15. None are squares.

The pattern here is that after the first element (5), the next elements are 1,4,3,2. So after 5, the elements are arranged in a way that their sum increments do not form squares.

So maybe the approach is to start with the largest element, then alternate between small and large elements to prevent the sum from hitting a square.

But how to make this systematic.

Alternatively, for the first element, use n. Then for the second element, use 1. Then the third element is n-1. Then the fourth is 2. And so on. This way, the sum increases in small steps, avoiding squares.

Let's test this pattern for n=4:

Permutation would be [4,1,3,2].

sum1=4 (square → 2^2). So invalid.

So this approach doesn't work for n=4.

But the sample uses [2,4,1,3], where the first element is 2 (non-square), then 4 (sum 6), then 1 (sum 7), then 3 (sum 10).

So the first element is not n. So why?

Because n=4 is a square. So sum1=4 would be invalid. So in this case, the first element cannot be 4. So we need to choose a different first element.

So for n=4, the first element is 2 (non-square), then the rest are arranged in a way that the sum doesn't hit a square.

So the approach depends on whether n is a square or not.

So here's a possible algorithm:

1. Check if the sum of all elements (n(n+1)/2) is a square. If yes, output -1.

2. Else:

   a. Check if n is a perfect square. If yes:

      i. Swap the first element (which would be a square) with another element to make it non-square. Then arrange the remaining elements in a way that avoids sums being squares.

   b. If n is not a square:

      i. Arrange the elements in reversed order (n, n-1, ..., 1). Check if any sum is a square. If not, output this permutation.

      ii. If any sum is a square, modify the permutation by swapping elements to break the square sums.

But this requires knowing which sums are squares and how to swap elements, which is not feasible for large n.

Alternatively, here's another approach inspired by the sample for n=4 and n=5:

For even n, start with 2, then n, then 1, then n-1, etc. Or some similar pattern.

But this is just a guess.

Alternatively, for even n, arrange even numbers first and then odd numbers, but in a way that their sum does not hit squares.

But this is vague.

An alternative idea is to construct the permutation in such a way that the sum after each step is one less than a square, or one more than a square. But how to ensure this.

Alternatively, the sum after each step should be between two consecutive squares. For example, between k^2 and (k+1)^2. So if the sum after i steps is between k^2 and (k+1)^2, then it's not a square.

But how to arrange the elements to stay within such ranges.

But this seems difficult.

Another Idea:

If n is not a square and the sum of the entire permutation is not a square, then the permutation [n, 1, 2, 3, ..., n-1] works. Let's check for n=3.

Permutation: [3,1,2].

Sum1=3 (not square).

Sum2=4 (square → invalid).

So this approach fails for n=3. So this is not a general solution.

But for n=5, the permutation [5,1,2,3,4] would have sums: 5,6,8, 11, 15. All are non-squares. So this works.

Wait, sum2 is 6, which is not a square. So for n=5, this works. For n=3, sum2 is 4 (square), which is invalid.

So why does this approach work for some n and not others?

Because for n=3, the sum after two steps is 3+1=4 (square). So for this approach to work, sum after i steps must be non-square.

But how to know for which n this approach works.

For n=5:

sum_i for the permutation [5,1,2,3,4] is:

i=1:5.

i=2:5+1=6.

i=3:6+2=8.

i=4:8+3=11.

i=5:11+4=15.

All are non-squares. So this works.

For n=6: permutation [6,1,2,3,4,5].

sum1:6 → not square.

sum2:7 → not.

sum3:9 → square → invalid.

So this approach fails for n=6.

Hmm. So the sum for i=3 is 6+1+2=9 (square), which is invalid.

So this approach is not general.

Thus, the challenge is to find a permutation for any n (where the sum is not a square) that has no prefix sums being squares.

Another Idea:

We can arrange the permutation in such a way that the first element is n, the second is n-1, the third is 1, the fourth is n-2, and so on. Let's see:

For n=4: [4,3,1,2].

sum1=4 (square → invalid).

So no good.

For n=5: [5,4,1,3,2].

sum1=5 → ok.

sum2=9 → square → invalid.

So no good.

Hmm.

Alternative Idea: Place the largest element first (if it's not a square), then the smallest elements, then the next largest, etc. This way, the sums might not hit squares.

For example, n=4:

[2,4,1,3].

sum1=2 → ok.

sum2=6 → ok.

sum3=7 → ok.

sum4=10 → ok.

This works. But why 2 first?

Because 4 is a square, so can't be first. So in this case, we have to avoid starting with 4.

Thus, when n is a square, the first element must be a non-square.

But how to choose which non-square to start with.

In the sample for n=4, the first element is 2. Then the next is 4 (sum 6), then 1 (sum7), then 3 (sum10).

So the idea is to alternate between large and small elements to prevent the sum from hitting a square.

But how to generalize this.

But perhaps the following approach works:

If n is a square, then the first element is 2, and the rest are arranged in a certain way.

But this is not helpful for a general solution.

Another Idea: For all n except those where the sum is a square, the permutation can be constructed as follows:

Start with the largest element. Then alternate between the smallest and next largest elements.

For example:

n=5: [5,1,4,2,3]. Sums:5,6,10,12,15. All non-squares.

n=4: [4,1,3,2]. Sums:4 (square), invalid.

So this approach would fail for n=4.

But if we start with the second largest element first, then arrange the largest, then others.

For n=4: [3,4,2,1]. sum1=3 (ok), sum2=7 (ok), sum3=9 (invalid).

So again, problem.

Hmm.

This is getting frustrating. I need to find a pattern or a method that can generate the permutation quickly.

Let's look for the pattern in the sample permutations:

Sample for n=4: [2,4,1,3].

sum1:2 (non-square).

sum2:6 (non-square).

sum3:7 (non-square).

sum4:10 (non-square).

Sample for n=5: [5,1,4,3,2].

sum1:5 (non-square).

sum2:6 (non-square).

sum3:10 (non-square).

sum4:13 (non-square).

sum5:15 (non-square).

So for n=5, the permutation starts with 5, then 1, then 4, then 3, then 2.

The pattern here seems to be:

Start with n (if possible), then add 1, then add the next largest possible element (n-1), then the next smallest (2), then the next largest (n-2), and so on.

But for n=5, this would be 5, 1,4, 2,3. Which gives sums:

5 → ok.

6 → ok.

10 → ok.

12 → ok.

15 → ok.

But the sample uses 5,1,4,3,2. Sum3 is 10, sum4 is 13, sum5 is 15.

But this also works.

So perhaps the pattern is to place elements in the order of n, 1, n-1, 3, n-2, etc.

But I'm not sure.

Alternatively, perhaps the permutation is formed by interleaving the largest remaining and smallest remaining elements.

For example:

For n=5:

Start with largest (5), then smallest (1), then next largest (4), then next smallest (2), then next largest (3). So permutation [5,1,4,2,3]. Sums:5,6,10,12,15. All non-squares.

This permutation works.

For n=4:

Start with largest (4) but it's a square, so instead start with the next largest non-square, which is 2. Then next largest (4), then smallest (1), then next (3). Which is the sample permutation.

But this requires knowing to swap when the first element is a square.

So perhaps the general approach is:

1. Check if the sum of all elements is a square. If yes, output -1.

2. Else:

   a. If n is a square, then swap the first element (n) with a non-square element.

   b. Then arrange the remaining elements in a way that the sum of each prefix is not a square.

But how to implement this.

But for code, given that n can be up to 1e9, we can't construct the permutation element by element. So there must be a pattern that allows us to output the permutation in O(1) time per test case.

But how?

Wait, the sample for n=5 outputs [5,1,4,3,2]. This is the reversed permutation, except the second element is 1 instead of 4. But perhaps the pattern is to swap the second and last elements.

But for n=5, reversing gives [5,4,3,2,1]. Sum2 is 5+4=9 (square). So this permutation is invalid.

So the sample swaps 4 with 1, making the permutation [5,1,4,3,2]. Sum2 is 6, sum3 is 10, etc.

So perhaps the strategy is to reverse the permutation and then swap the second element with the last element. But how to verify.

For n=4, reversed is [4,3,2,1]. Sum3=9 (square). So need to modify. Sample swaps 3 and 1, 2 and 3, etc. But it's not clear.

Alternative Idea inspired by the sample:

For n=4, the permutation is [2,4,1,3]. Sum after each step is 2,6,7,10.

The elements are arranged such that the first two elements sum to 6 (non-square), then 7, then 10.

So the pattern seems to be:

- The first element is a non-square (2 for n=4).

- The second element is the largest possible (4 for n=4).

- The third element is the smallest possible (1).

- The fourth is next available (3).

So perhaps the general approach is:

If n is a square, the permutation starts with 2, then n, then 1, then the remaining elements arranged in reverse order (excluding the ones already used).

But this is just a guess.

But how to generalize this.

Another Idea: For n is a square, the first element is 2, the second is n, the third is 1, then the rest are arranged in reverse order.

For example, n=4: [2,4,1,3]. Which matches the sample.

For n=9 (which is a square):

sum = 9*10/2 =45, which is not a square. So possible.

Permutation would be [2,9,1,8,7,6,5,4,3]. Let's check sums:

sum1=2 → ok.

sum2=11 → ok.

sum3=12 → ok.

sum4=20 → ok.

sum5=27 → ok.

sum6=33 → ok.

sum7=38 → ok.

sum8=42 → ok.

sum9=45 → ok.

All are non-squares. So this works.

So this pattern works for n=9.

But how to verify.

But this approach is only for when n is a square. What about when n is not a square but the sum is not a square.

For example, n=5, which is not a square. sum=15 (not a square). permutation is [5,4,3,2,1]. Sum2=9 (square). So reversed permutation is invalid. But the sample uses [5,1,4,3,2], which avoids this.

So for non-square n, but some prefix sums in reversed permutation are squares, the approach is to swap elements.

But again, how to do this systematically.

But for code, it's impossible to check each prefix sum for large n.

So perhaps the only way is to find that the permutation can be constructed as follows:

If n is not a square and the sum is not a square, then the reversed permutation works. But this is not true (as seen for n=5). So this approach is invalid.

Thus, I'm stuck. Maybe there's a different way to approach the problem.

Let's think of the possible cases where a permutation exists.

Case 1: n=1 → sum is 1 (square) → output -1.

Case 2: sum is a square → output -1.

Else, output a permutation. But how.

Wait, the sample for n=4 works even though n is a square (4 is 2^2). But the sum is 10, not a square. So the problem is not with n being a square, but with the sum of the entire permutation.

So the key is to check whether the total sum is a square. If yes, output -1. Otherwise, construct a permutation.

But how to construct the permutation.

Another Idea: If the sum is not a square, then the permutation can be constructed by reversing the permutation and, if any prefix sum is a square, swap elements to break it. But this is not feasible for large n.

Alternatively, here's a pattern that works for the sample and some other cases:

The permutation is constructed by reversing the array and swapping the first two elements if necessary.

For example:

n=4, reversed permutation is [4,3,2,1]. sum3 is 9. To break this, swap the third and fourth elements: [4,3,1,2]. sum3=4+3+1=8 (not square). sum4=10.

But sum1=4 (square). So this is invalid.

So swap the first element with another. For example, swap 4 and 2. permutation [2,3,4,1]. sum3=9. Again invalid.

Another swap: swap 3 and 1. permutation [4,1,2,3]. sum1=4 (invalid).

Hmm.

Another Idea: For n=4, the sum of the first i elements in the sample permutation is:

i=1:2 → 2.

i=2:2+4=6.

i=3:6+1=7.

i=4:7+3=10.

None are squares.

The permutation is [2,4,1,3]. This seems to be constructed by placing 2 and 4 in the first two positions, then the remaining elements in increasing order.

But how.

Another Idea: For the first two elements, arrange them such that their sum is not a square. Then arrange the rest elements in such a way that their addition doesn't create a square.

But again, this is not a general solution.

Perhaps the correct approach is to realize that for any n where the sum is not a square, there exists a permutation. So the problem reduces to checking whether the sum is a square. If not, output any permutation that meets the criteria.

But how to construct such a permutation quickly.

But for code submission, perhaps the following approach works:

If the sum is a square, output -1.

Else, output the permutation reversed, except for when the first element is a square.

Wait, for example:

If n is a square, swap the first element with the second.

Else, reverse the permutation.

But let's test this.

For n=4: sum is 10 (not a square). But n=4 is a square, so swap first and second elements. So permutation is [3,4,2,1]. sum1=3 (not square), sum2=7 (not), sum3=9 (square). Invalid.

So this approach doesn't work.

Hmm.

Another Idea: The permutation can be constructed by placing the elements in reverse order, except for swapping the first element with the second if the first element is a square.

For example, n=4: [3,4,2,1]. sum1=3, sum2=7, sum3=9 → invalid.

No.

Alternatively, swap the first element with the third. For n=4: [2,3,4,1]. sum3=2+3+4=9 → invalid.

No.

This is getting us nowhere.

Perhaps there's a pattern for even and odd n.

For even n:

- Start with 2, then n, then 1, then n-1, then 3, then n-2, etc.

For odd n:

- Start with n, then 1, then n-1, then 2, then n-2, etc.

Let's see:

n=4 (even):

Permutation [2,4,1,3].

sum1=2.

sum2=6.

sum3=7.

sum4=10.

All non-squares. Works.

n=5 (odd):

Permutation [5,1,4,2,3].

sum1=5.

sum2=6.

sum3=10.

sum4=12.

sum5=15.

All non-squares. Works.

n=6 (even):

Permutation [2,6,1,5,3,4].

sum1=2.

sum2=8.

sum3=9 → square. Invalid.

So this approach fails for n=6.

Hmm.

But maybe the pattern needs adjustment.

For n=6, the sum of the permutation is 21, which is not a square. So output must exist.

Possible permutation:

[3,6,2,5,1,4].

sum1=3 → not square.

sum2=9 → square. Invalid.

Another permutation: [6,3,2,5,1,4]. sum1=6, sum2=9 (invalid).

Hmm.

Another Idea: For even n, start with the second largest even number. For example, n=4 is even. Start with 2 (second even), then 4, then 1, then 3.

But this is the sample.

For n=6, even, start with 4 (second even), then 6, then 2, then 5, then 1, then 3.

sum1=4 (square) → invalid.

Not helpful.

This is taking too long. Let's think differently.

According to the problem statement, the sum of the entire permutation must not be a square. So first check that.

Then, for the permutation, the key is to make sure that the sum of the first i elements is not a square for any i.

But how to arrange this.

Perhaps the following approach works:

For i from 1 to n:

- Ensure that the sum up to i is not a square.

But how to do this.

But for large n, we need a pattern.

An alternative Idea: The sum after i elements in the permutation is the sum of the first i elements in the permutation. To avoid squares, we can arrange the permutation such that each new element added increases the sum by a non-square amount.

But how to do this.

Alternatively, for each i, the sum up to i can be checked for being a square, and if it is, swap the i-th element with another.

But for code, this is not feasible for large n.

So perhaps the correct way is to note that for n >= 2, except when the sum is a square, a permutation exists. And one possible way to construct it is to reverse the permutation and, if any sum is a square, swap two elements to break it.

But how to implement this without checking each sum.

But perhaps the only time a reversed permutation is invalid is when the sum for i=1 is a square (n is a square), or for some i>1.

So for code:

If the sum of the entire permutation is a square → output -1.

Else:

   if n is a square → we need to swap the first element with another element to make sum1 not a square.

   Then, the rest of the permutation is reversed, but maybe need to swap other elements.

But how.

Alternatively, here's a code approach:

For each test case:

   compute sum = k*(k+1)//2.

   check if sum is a perfect square. If yes, output -1.

   else:

       if k is 1:

           output -1.

       else:

           construct the permutation in reverse order, but if the first element is a square, swap it with the second element.

           then output the permutation.

But will this work?

For example, n=4:

sum is 10 (not square). n is a square (4=2^2).

So code constructs reversed permutation [4,3,2,1], but the first element is 4 (square). So swap first two elements → [3,4,2,1].

Check sums:

sum1=3 → ok.

sum2=7 → ok.

sum3=9 → square. So invalid.

So this approach fails.

Hmm.

Alternative Idea: For n being a square, swap the first element with the last element.

For n=4, this gives [1,3,2,4].

sum1=1 → square → invalid.

No.

This is not helpful.

Another Idea: For n being a square, start with 2, then the rest are in reverse order except the first element.

For n=4, permutation is [2,4,3,1].

sum1=2 → ok.

sum2=6 → ok.

sum3=9 → square. invalid.

Hmm.

This is not working.

Alternative Idea inspired by the sample for n=4:

The sample permutation is [2,4,1,3]. The first two elements are 2 and 4, which sum to 6. Then 1 sum to 7, then 3 to 10.

So the first two elements are even numbers in reverse order (4, 2) but the first is 2 and the second is 4. Then 1 and 3.

So perhaps for even n that is a square, arrange even elements first in some order, then odds.

But I'm not sure.

Another Idea: For even n, start with 2, then n, then 1, then n-1, and so on.

For n=4: [2,4,1,3].

sum1=2 → ok.

sum2=6 → ok.

sum3=7 → ok.

sum4=10 → ok.

For n=6 (sum is 21, not square):

 permutation would be [2,6,1,5,3,4].

sum1=2 → ok.

sum2=8 → ok.

sum3=9 → square. invalid.

So this approach fails.

But sum3 is 9 (square), which is invalid.

Thus, this approach is not reliable.

At this point, I'm stuck. Perhaps the correct way is to refer to some mathematical property.

Let's think about the problem again. The sum of the permutation is fixed as n(n+1)/2. We need to ensure that this sum is not a square. For cases where this sum is not a square, it is possible to construct a permutation.

The sample for n=4, sum=10 (not square), and a permutation exists.

But how?

An alternative approach for code:

For each test case:

   read k.

   compute sum = k*(k+1)//2.

   check if sum is a perfect square. If yes, output -1.

   else:

       output the permutation as [k, 1, k-1, 2, k-2, 3, ...].

       check if any of the prefix sums in this permutation are squares. If not, output it.

But for large k, this is not feasible.

But perhaps this pattern works.

Let's test it for n=4:

 permutation [4,1,3,2].

sum1=4 (square → invalid).

So this approach fails.

For n=5:

 permutation [5,1,4,2,3].

sum1=5 → ok.

sum2=6 → ok.

sum3=10 → ok.

sum4=12 → ok.

sum5=15 → ok.

So works.

For n=3:

 permutation [3,1,2].

sum1=3 → ok.

sum2=4 → square. invalid.

So this approach fails.

For n=6:

 permutation [6,1,5,2,4,3].

sum1=6 → ok.

sum2=7 → ok.

sum3=12 → ok.

sum4=14 → ok.

sum5=18 → ok.

sum6=21 → ok.

All sums are non-squares. So this works.

For n=6, this permutation is valid.

Thus, this approach may work for even and odd n.

But for some cases like n=3 and n=4, it doesn't work.

So the pattern is:

Arrange the permutation as [n, 1, n-1, 2, n-2, 3, ...].

But why this works for some n and not others.

For example, n=3:

 permutation [3,1,2].

sum2=4 → square. invalid.

But n=3's sum is 6 (not a square). So permutation exists, but this approach fails.

But there's another permutation that works, like [2,3,1].

So the approach is not general.

But for code submission, perhaps the correct way is to output this pattern if it works for the given n.

But how to verify if this pattern works.

But for code submission, given time constraints, perhaps the only way is to output this pattern and hope that it works for all cases except when the sum is a square.

But this is risky.

Alternatively, given that the problem allows any valid permutation, perhaps this pattern works for all n except when the sum is a square.

But for n=3, it fails. So why?

Because the sum of the first two elements is 3+1=4, which is a square.

But there exists another permutation that works.

So, the problem is that this pattern may fail for some n, but another permutation exists.

So, perhaps the code can use this pattern and check if any prefix sum is a square. If not, output it. Else, find another pattern.

But for code submission with n up to 1e9, this is impossible.

Thus, the correct approach must be to check if the sum is a square. If not, output the permutation as [k, 1, k-1, 2, k-2, 3, ...], even if for some cases like n=3, it's invalid.

But the sample for n=3 is not given. Wait, the sample input for n=5 works. So what about n=3?

The sample input for n=3 is not given, but according to earlier analysis, permutation [2,3,1] works.

But how to generate such a permutation for code submission.

Given time constraints, perhaps the correct approach is:

If the sum is a square → output -1.

Else, output the permutation as follows: [n, 1, n-1, 2, n-2, 3, ...].

But this may not work for all cases.

But in the sample for n=4, this approach fails, but the sample uses a different permutation.

But perhaps the code can use this pattern regardless, and hope that it passes the test cases.

But in code submission, for n=3, this pattern would output [3,1,2], which sum2=4 (square), and thus invalid. But there exists a valid permutation. So the code would output an invalid permutation, but the problem requires to output any valid permutation.

Thus, this approach is incorrect.

But the problem requires that the code outputs a valid permutation if it exists.

Thus, I'm stuck.

Perhaps the correct approach is to realize that when the sum is not a square, the permutation can be constructed by reversing the order except for swapping the first two elements if the first element is a square.

But how to verify this.

For example:

n=4 → sum 10.

reversed permutation is [4,3,2,1].

sum3=9 (square).

So we need to swap elements to break this.

But how.

Another Idea: For even n, start with 2, then n, then 1, then n-1, and so on.

For n=4: [2,4,1,3] → sample.

For n=6: [2,6,1,5,3,4].

sum1=2 → ok.

sum2=8 → ok.

sum3=9 → square → invalid.

Thus, this approach fails for n=6.

But for n=6, the permutation [6,3,2,5,1,4] gives sums:

6 → ok.

9 → square → invalid.

Thus, this approach also fails.

At this point, I'm forced to conclude that there's no obvious pattern, and the problem requires a different approach.

Upon further research, I recall that the only known solutions where n(n+1)/2 is a square are for n=0, 1, 8, 49, etc. These are known as square triangular numbers.

Thus, for all other n, a permutation exists. So the code must:

- Check if sum is a square. If yes, output -1.

- Else, output any permutation that avoids prefix sums being squares.

But how to construct such a permutation.

An alternative Idea: The permutation can be constructed as the reverse of [1,2,...,n], except for the first two elements if needed.

But this is vague.

Another Idea: For n >=2, the permutation can be [2, 1, 3, 4, ..., n]. Let's check:

n=2 → [2,1]. sum1=2, sum2=3. Valid.

n=3 → [2,1,3]. sum1=2, sum2=3, sum3=6. Valid.

n=4 → [2,1,3,4]. sum1=2, sum2=3, sum3=6, sum4=10. Valid.

n=5 → [2,1,3,4,5]. sum3=6 → square for i=3 (6 is not a square). sum3=6, which is not a square. So sum3=6 is ok.

Wait, 6 is not a square. So this permutation is valid.

Thus, this pattern seems to work.

Check for n=4:

sum4=2+1+3+4=10 → ok.

n=5:

sum5=2+1+3+4+5=15 → ok.

n=6:

sum6=2+1+3+4+5+6=21 → ok.

sum3=2+1+3=6 → ok.

sum4=2+1+3+4=10 → ok.

sum5=15 → ok.

Thus, this permutation works for all n >=2, except when the sum is a square.

But why?

Because the sum after each step is:

i=1:2 (not square).

i=2:3 (not).

i=3:6 (not square).

i=4:10 (not).

i=5:15 (not).

i=6:21 (not).

etc.

So this permutation seems to work.

But how.

The permutation is [2, 1, 3,4,5,...,n].

Sum for i=1 is 2.

For i=2: 2+1=3.

For i >=3: sum is 3 + 3 +4 + ... +i-th element.

Wait, the first two elements are 2 and 1. The rest are 3,4,5,...,n in order.

Thus, the sum for i=3 is 2+1+3=6.

For i=4: 6+4=10.

i=5:10+5=15.

i=6:15+6=21.

These sums are 2,3,6,10,15,21. None of which are squares.

Thus, this pattern works for n >=2.

But why?

Because after the first two elements, the sum is 3, then adding 3 gives 6, then adding 4 gives 10, etc. These sums are all triangular numbers (sum of consecutive integers), but no triangular numbers after 1 are perfect squares except for the known square triangular numbers.

Thus, this permutation works.

So the code can construct the permutation as follows:

For n=1 → output -1.

Else, if sum is a square → output -1.

Else, output the permutation [2, 1] followed by the numbers 3 to n in order.

This seems to work.

Let's test:

n=3: permutation [2,1,3].

sum1=2 → ok.

sum2=3 → ok.

sum3=6 → ok.

Valid.

n=4: [2,1,3,4].

sum1=2, sum2=3, sum3=6, sum4=10 → all valid.

n=5: [2,1,3,4,5] sums are 2,3,6,10,15 → valid.

n=6: sums 2,3,6,10,15,21 → valid.

n=7: sums 2,3,6,10,15,21,28 → valid.

Thus, this pattern works.

But what about cases where the sum of the entire permutation is a square, but the individual prefixes are not.

For example, n=8:

sum is 36 → square (6^2). So output -1.

But the permutation pattern is [2,1,3,4,5,6,7,8]. sum8=36 → square. So in this case, the code would correctly output -1.

Thus, the code can be written as follows:

For each test case:

   Read k.

   If k ==1: output -1.

   Compute sum = k*(k+1)//2.

   Check if sum is a perfect square.

   If yes: output -1.

   Else:

       Output 2, 1, followed by 3,4,5,...,k.

This permutation will have all prefix sums not squares.

But how to check if sum is a perfect square.

Checking for sum being a square can be done by taking the integer square root and squaring to check.

But for large numbers up to 1e9* (1e9 +1)/2, which is about 5e17, we need to compute the square root accurately.

In Python, this can be done using math.isqrt for integers, which returns the largest integer less than or equal to the square root. For example:

def is_square(x):
    s = math.isqrt(x)
    return s * s == x

This will correctly check if x is a square.

Thus, the code will be:

import math

t = int(input())

for _ in range(t):
    k = int(input())
    if k ==1:
        print(-1)
        continue
    total = k * (k+1) // 2
    s = math.isqrt(total)
    if s * s == total:
        print(-1)
    else:
        ans = [2,1]
        if k >2:
            ans += list(range(3, k+1))
        print(' '.join(map(str, ans)))

But let's test this code against the samples.

Sample Input 1: 1.

Output: -1. Correct.

Sample Input 4: sum is 4*5/2=10. Not a square. Code outputs [2,1,3,4]. Sums:

2 → ok.

3 → ok.

6 → ok.

10 → ok. Correct.

Sample Input 5: sum 15, not a square. Code outputs [2,1,3,4,5]. Sums are 2,3,6,10,15. All non-squares. But the sample output is [5,1,4,3,2]. But the problem accepts any valid permutation. So the code's output is also valid.

Thus, the code passes the sample cases.

For n=3: code outputs [2,1,3], which is valid.

For n=6: code outputs [2,1,3,4,5,6]. Sums are 2,3,6,10,15,21. All non-squares.

Thus, the code is correct.